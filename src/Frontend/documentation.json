{
    "pipes": [],
    "interfaces": [
        {
            "name": "IErrorDto",
            "id": "interface-IErrorDto-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "properties": [
                {
                    "name": "description",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 622
                }
            ],
            "indexSignatures": [],
            "kind": 165,
            "methods": []
        },
        {
            "name": "ILoginDto",
            "id": "interface-ILoginDto-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "properties": [
                {
                    "name": "email",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 661
                },
                {
                    "name": "password",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 662
                }
            ],
            "indexSignatures": [],
            "kind": 165,
            "methods": []
        },
        {
            "name": "ILoginResultDto",
            "id": "interface-ILoginResultDto-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "properties": [
                {
                    "name": "error",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "LoginError",
                    "optional": true,
                    "description": "",
                    "line": 710
                },
                {
                    "name": "succeded",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "optional": true,
                    "description": "",
                    "line": 709
                },
                {
                    "name": "token",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 711
                }
            ],
            "indexSignatures": [],
            "kind": 165,
            "methods": []
        },
        {
            "name": "IProblemDetails",
            "id": "interface-IProblemDetails-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "properties": [
                {
                    "name": "detail",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 762
                },
                {
                    "name": "instance",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 763
                },
                {
                    "name": "status",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number | undefined",
                    "optional": true,
                    "description": "",
                    "line": 761
                },
                {
                    "name": "title",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 760
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 759
                }
            ],
            "indexSignatures": [],
            "kind": 165,
            "methods": []
        },
        {
            "name": "IProductDto",
            "id": "interface-IProductDto-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "properties": [
                {
                    "name": "calories",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": true,
                    "description": "",
                    "line": 813
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": true,
                    "description": "",
                    "line": 811
                },
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 812
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": true,
                    "description": "",
                    "line": 814
                },
                {
                    "name": "unit",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": true,
                    "description": "",
                    "line": 815
                }
            ],
            "indexSignatures": [],
            "kind": 165,
            "methods": []
        },
        {
            "name": "IRegisterDto",
            "id": "interface-IRegisterDto-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "properties": [
                {
                    "name": "email",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 858
                },
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 857
                },
                {
                    "name": "password",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 859
                }
            ],
            "indexSignatures": [],
            "kind": 165,
            "methods": []
        },
        {
            "name": "IRegisterResultDto",
            "id": "interface-IRegisterResultDto-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "properties": [
                {
                    "name": "error",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "RegisterError",
                    "optional": true,
                    "description": "",
                    "line": 909
                },
                {
                    "name": "succeded",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "optional": true,
                    "description": "",
                    "line": 908
                },
                {
                    "name": "token",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 910
                }
            ],
            "indexSignatures": [],
            "kind": 165,
            "methods": []
        },
        {
            "name": "Meal",
            "id": "interface-Meal-88e098d06a9fc33a68c20aa0d56560ddfc7c87c437dbab0d1eeb9f7cdc8ed72bf056ee091a91fdb03a25e3cc7d6a5c1291745c0efa876e9de9b692a5cb5ec340",
            "file": "src/app/models/meal.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { MealProduct } from \"./mealproduct\";\r\n\r\nexport interface Meal {\r\n    id: number;\r\n    type: TypeOfMeal;\r\n    date: Date;\r\n    products: Array<MealProduct>;// Array\r\n}\r\n\r\nexport enum TypeOfMeal {\r\n    breakfast,\r\n    lunch,\r\n    dinner,\r\n    snack\r\n}",
            "properties": [
                {
                    "name": "date",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Date",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 4
                },
                {
                    "name": "products",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<MealProduct>",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TypeOfMeal",
                    "optional": false,
                    "description": "",
                    "line": 5
                }
            ],
            "indexSignatures": [],
            "kind": 165,
            "methods": []
        },
        {
            "name": "MealProduct",
            "id": "interface-MealProduct-0b1249ae17bf0fafbd5b4de91329bfa22e2ae5faf693d07e49f3664a065f741774e2a7d6cd6d06b56e1d14fbd35268ceaf70c48ace9541b40c75f990afc5e084",
            "file": "src/app/models/mealproduct.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface MealProduct{\r\n    id: number;\r\n    productId: number;\r\n    date: Date; //  ?\r\n    amount: number;  \r\n}\r\n",
            "properties": [
                {
                    "name": "amount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "date",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Date",
                    "optional": false,
                    "description": "",
                    "line": 4
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 2
                },
                {
                    "name": "productId",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 3
                }
            ],
            "indexSignatures": [],
            "kind": 165,
            "methods": []
        },
        {
            "name": "SelectedProductParams",
            "id": "interface-SelectedProductParams-8123687c3c7b0a0a579039766de2b3147397644e0a7e7d186b5fadfa665860d3d08da7b7b0c4ebcf26cd664bb1a4f338343bd8a027f38adf9797c86c6103c6c2",
            "file": "src/app/models/selected-product-params.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { TypeOfMeal } from \"./meal\";\r\nimport { Product } from \"./product\";\r\n\r\nexport interface SelectedProductParams{\r\n    product: Product;\r\n    typeofMeal: TypeOfMeal;\r\n    amount: number;\r\n}",
            "properties": [
                {
                    "name": "amount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "product",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Product",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "typeofMeal",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TypeOfMeal",
                    "optional": false,
                    "description": "",
                    "line": 6
                }
            ],
            "indexSignatures": [],
            "kind": 165,
            "methods": []
        },
        {
            "name": "User",
            "id": "interface-User-9c7e5f1bbbab702cb032307d130876cb68969b0cd4eedef32a0c8cad8081a54e5f8f577ed6ad4539c1b99a1d246cb34031d198c2ea8eba440e64e91b14f01fdc",
            "file": "src/stories/User.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "export interface User {}\n",
            "properties": [],
            "indexSignatures": [],
            "methods": []
        }
    ],
    "injectables": [
        {
            "name": "ApiClient",
            "id": "injectable-ApiClient-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "properties": [
                {
                    "name": "baseUrl",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 21,
                    "modifierKind": [
                        121
                    ]
                },
                {
                    "name": "http",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "HttpClient",
                    "optional": false,
                    "description": "",
                    "line": 20,
                    "modifierKind": [
                        121
                    ]
                },
                {
                    "name": "jsonParseReviver",
                    "defaultValue": "undefined",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": " | undefined",
                    "optional": false,
                    "description": "",
                    "line": 22,
                    "modifierKind": [
                        122
                    ]
                }
            ],
            "methods": [
                {
                    "name": "createProduct",
                    "args": [
                        {
                            "name": "body",
                            "type": "ProductDto | undefined",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<ProductDto>",
                    "typeParameters": [],
                    "line": 508,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\n",
                    "description": "",
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 25130,
                                "end": 25134,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "escapedText": "body"
                            },
                            "type": "ProductDto | undefined",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "pos": 25124,
                                "end": 25129,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "escapedText": "param"
                            },
                            "comment": "<p>(optional)</p>\n"
                        },
                        {
                            "tagName": {
                                "pos": 25155,
                                "end": 25161,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "originalKeywordKind": 105,
                                "escapedText": "return"
                            },
                            "comment": "<p>Created</p>\n"
                        }
                    ]
                },
                {
                    "name": "deleteProduct",
                    "args": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<ProductDto>",
                    "typeParameters": [],
                    "line": 348,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\n",
                    "description": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "tagName": {
                                "pos": 17176,
                                "end": 17182,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "originalKeywordKind": 105,
                                "escapedText": "return"
                            },
                            "comment": "<p>No Content</p>\n"
                        }
                    ]
                },
                {
                    "name": "find",
                    "args": [
                        {
                            "name": "name",
                            "type": "string | undefined",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<ProductDto[]>",
                    "typeParameters": [],
                    "line": 431,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\n",
                    "description": "",
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 21483,
                                "end": 21487,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "escapedText": "name"
                            },
                            "type": "string | undefined",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "pos": 21477,
                                "end": 21482,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "escapedText": "param"
                            },
                            "comment": "<p>(optional)</p>\n"
                        },
                        {
                            "tagName": {
                                "pos": 21508,
                                "end": 21514,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "originalKeywordKind": 105,
                                "escapedText": "return"
                            },
                            "comment": "<p>Success</p>\n"
                        }
                    ]
                },
                {
                    "name": "getProduct",
                    "args": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<ProductDto>",
                    "typeParameters": [],
                    "line": 172,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\n",
                    "description": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "tagName": {
                                "pos": 7935,
                                "end": 7941,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "originalKeywordKind": 105,
                                "escapedText": "return"
                            },
                            "comment": "<p>Success</p>\n"
                        }
                    ]
                },
                {
                    "name": "login",
                    "args": [
                        {
                            "name": "body",
                            "type": "LoginDto | undefined",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<LoginResultDto>",
                    "typeParameters": [],
                    "line": 33,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\n",
                    "description": "",
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 1198,
                                "end": 1202,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "escapedText": "body"
                            },
                            "type": "LoginDto | undefined",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "pos": 1192,
                                "end": 1197,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "escapedText": "param"
                            },
                            "comment": "<p>(optional)</p>\n"
                        },
                        {
                            "tagName": {
                                "pos": 1223,
                                "end": 1229,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "originalKeywordKind": 105,
                                "escapedText": "return"
                            },
                            "comment": "<p>Success</p>\n"
                        }
                    ]
                },
                {
                    "name": "processCreateProduct",
                    "args": [
                        {
                            "name": "response",
                            "type": "HttpResponseBase",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<ProductDto>",
                    "typeParameters": [],
                    "line": 538,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        122
                    ],
                    "jsdoctags": [
                        {
                            "name": "response",
                            "type": "HttpResponseBase",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "processDeleteProduct",
                    "args": [
                        {
                            "name": "response",
                            "type": "HttpResponseBase",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<ProductDto>",
                    "typeParameters": [],
                    "line": 377,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        122
                    ],
                    "jsdoctags": [
                        {
                            "name": "response",
                            "type": "HttpResponseBase",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "processFind",
                    "args": [
                        {
                            "name": "response",
                            "type": "HttpResponseBase",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<ProductDto[]>",
                    "typeParameters": [],
                    "line": 461,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        122
                    ],
                    "jsdoctags": [
                        {
                            "name": "response",
                            "type": "HttpResponseBase",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "processGetProduct",
                    "args": [
                        {
                            "name": "response",
                            "type": "HttpResponseBase",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<ProductDto>",
                    "typeParameters": [],
                    "line": 201,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        122
                    ],
                    "jsdoctags": [
                        {
                            "name": "response",
                            "type": "HttpResponseBase",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "processLogin",
                    "args": [
                        {
                            "name": "response",
                            "type": "HttpResponseBase",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<LoginResultDto>",
                    "typeParameters": [],
                    "line": 63,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        122
                    ],
                    "jsdoctags": [
                        {
                            "name": "response",
                            "type": "HttpResponseBase",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "processRegister",
                    "args": [
                        {
                            "name": "response",
                            "type": "HttpResponseBase",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<RegisterResultDto>",
                    "typeParameters": [],
                    "line": 133,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        122
                    ],
                    "jsdoctags": [
                        {
                            "name": "response",
                            "type": "HttpResponseBase",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "processUpdateProduct",
                    "args": [
                        {
                            "name": "response",
                            "type": "HttpResponseBase",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<ProductDto>",
                    "typeParameters": [],
                    "line": 288,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        122
                    ],
                    "jsdoctags": [
                        {
                            "name": "response",
                            "type": "HttpResponseBase",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "register",
                    "args": [
                        {
                            "name": "body",
                            "type": "RegisterDto | undefined",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<RegisterResultDto>",
                    "typeParameters": [],
                    "line": 103,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\n",
                    "description": "",
                    "jsdoctags": [
                        {
                            "name": {
                                "pos": 4553,
                                "end": 4557,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "escapedText": "body"
                            },
                            "type": "RegisterDto | undefined",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "pos": 4547,
                                "end": 4552,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "escapedText": "param"
                            },
                            "comment": "<p>(optional)</p>\n"
                        },
                        {
                            "tagName": {
                                "pos": 4578,
                                "end": 4584,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "originalKeywordKind": 105,
                                "escapedText": "return"
                            },
                            "comment": "<p>Success</p>\n"
                        }
                    ]
                },
                {
                    "name": "updateProduct",
                    "args": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "body",
                            "type": "ProductDto | undefined",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<ProductDto>",
                    "typeParameters": [],
                    "line": 255,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\n",
                    "description": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": {
                                "pos": 12227,
                                "end": 12231,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "escapedText": "body"
                            },
                            "type": "ProductDto | undefined",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "pos": 12221,
                                "end": 12226,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "escapedText": "param"
                            },
                            "comment": "<p>(optional)</p>\n"
                        },
                        {
                            "tagName": {
                                "pos": 12252,
                                "end": 12258,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "originalKeywordKind": 105,
                                "escapedText": "return"
                            },
                            "comment": "<p>Success</p>\n"
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "http",
                        "type": "HttpClient",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "baseUrl",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    }
                ],
                "line": 22,
                "jsdoctags": [
                    {
                        "name": "http",
                        "type": "HttpClient",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "baseUrl",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "HttpService",
            "id": "injectable-HttpService-c0651051f783a99a12754469f3db2e3549abfe3249922fcc91e7db99714ccc13acd02c12480193a21b429af9b58f4c1048505cf5bb20afb40af0449e3964af8a",
            "file": "src/app/services/http.service.ts",
            "properties": [
                {
                    "name": "http",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "HttpClient",
                    "optional": false,
                    "description": "",
                    "line": 11,
                    "modifierKind": [
                        121,
                        144
                    ]
                }
            ],
            "methods": [
                {
                    "name": "getProducts",
                    "args": [],
                    "optional": false,
                    "returnType": "Observable<Product[]>",
                    "typeParameters": [],
                    "line": 23,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 13,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { startWith, map, tap, catchError, Observable } from 'rxjs';\r\nimport { HttpClient } from '@angular/common/http'; \r\nimport { Injectable, OnInit } from '@angular/core';\r\nimport { Product } from '../models/product';\r\n\r\n@Injectable({\r\n    providedIn: 'root'\r\n})\r\nexport class HttpService implements OnInit {\r\n\r\nprivate readonly http: HttpClient;\r\n\r\n    ngOnInit(): void {\r\n        \r\n    }\r\n\r\n\r\n\r\nconstructor(http:HttpClient){\r\n    this.http = http;\r\n}\r\n\r\n    getProducts(): Observable<Product[]> {\r\n        return this.http.get('https://localhost:49714/api/products').pipe(map((data: any) => {\r\n            let productList = data;\r\n            return productList.map(function (product: any): Product {\r\n                return new product(product.id, product.name, product.calories, product.type, product.unit);\r\n            });\r\n        }));\r\n    }\r\n}",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "http",
                        "type": "HttpClient",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 15,
                "jsdoctags": [
                    {
                        "name": "http",
                        "type": "HttpClient",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "MealsController",
            "id": "injectable-MealsController-f2060c6e1a66ae20b0e7b27c2241057c5805ecf2bcb119dd0b2ec9348b7635c9416a0991523bca99023a8a36e02a9a714e58f27be306db67d4f088d4c317b7ce",
            "file": "src/app/services/meals.controller.ts",
            "properties": [
                {
                    "name": "isFocused$",
                    "defaultValue": "new Subject<TypeOfMeal>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 12,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "porductSelected$",
                    "defaultValue": "new Subject<SelectedProductParams>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 13,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methods": [
                {
                    "name": "addProduct",
                    "args": [
                        {
                            "name": "product",
                            "type": "Product",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "typeOfMeal",
                            "type": "TypeOfMeal",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 19,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "product",
                            "type": "Product",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "typeOfMeal",
                            "type": "TypeOfMeal",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setFocus",
                    "args": [
                        {
                            "name": "type",
                            "type": "TypeOfMeal",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 15,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "type",
                            "type": "TypeOfMeal",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable } from '@angular/core';\r\nimport { Subject } from 'rxjs';\r\nimport { TypeOfMeal } from '../models/meal';\r\nimport { Product } from '../models/product';\r\nimport { SelectedProductParams } from '../models/selected-product-params';\r\n@Injectable({\r\n    providedIn: 'root'\r\n})\r\n\r\nexport class MealsController {\r\n\r\n    public isFocused$ = new Subject<TypeOfMeal>();\r\n    public porductSelected$ = new Subject<SelectedProductParams>();\r\n\r\n    public setFocus(type: TypeOfMeal) {\r\n        this.isFocused$.next(type);\r\n    }\r\n\r\n    public addProduct(product: Product, typeOfMeal: TypeOfMeal, amount: number) {\r\n        this.porductSelected$.next({ product: product, typeofMeal: typeOfMeal, amount: amount });\r\n    }\r\n}",
            "type": "injectable"
        },
        {
            "name": "MealsService",
            "id": "injectable-MealsService-6ff069bc190b89a89c4789a64f7c4ba07f03151844e81badffb25bcc9d0388f0641d86d14485846f89627a38535bada3d0722db91cec22a896221ca6061aaabf",
            "file": "src/app/services/meals.service.ts",
            "properties": [
                {
                    "name": "breakfast",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<MealProduct>",
                    "optional": false,
                    "description": "",
                    "line": 13
                },
                {
                    "name": "date",
                    "defaultValue": "new Date",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 12,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "destroy$",
                    "defaultValue": "new Subject()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 20,
                    "modifierKind": [
                        121
                    ]
                },
                {
                    "name": "dinner",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<MealProduct>",
                    "optional": false,
                    "description": "",
                    "line": 15
                },
                {
                    "name": "lunch",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<MealProduct>",
                    "optional": false,
                    "description": "",
                    "line": 14
                },
                {
                    "name": "meal",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Meal",
                    "optional": false,
                    "description": "",
                    "line": 18
                },
                {
                    "name": "mealId",
                    "defaultValue": "0",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 11
                },
                {
                    "name": "meals",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<Meal>",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "mealsController",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MealsController",
                    "optional": false,
                    "description": "",
                    "line": 19,
                    "modifierKind": [
                        121,
                        144
                    ]
                },
                {
                    "name": "snack",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<MealProduct>",
                    "optional": false,
                    "description": "",
                    "line": 16
                }
            ],
            "methods": [
                {
                    "name": "addMeal",
                    "args": [
                        {
                            "name": "typeOfMeal",
                            "type": "TypeOfMeal",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "date",
                            "type": "Date",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "mealproducts",
                            "type": "Array<MealProduct>",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 27,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "typeOfMeal",
                            "type": "TypeOfMeal",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "date",
                            "type": "Date",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "mealproducts",
                            "type": "Array<MealProduct>",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "addMealProduct",
                    "args": [
                        {
                            "name": "mealProduct",
                            "type": "MealProduct",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "type",
                            "type": "TypeOfMeal",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 73,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "mealProduct",
                            "type": "MealProduct",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "type",
                            "type": "TypeOfMeal",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "deleteMeal",
                    "args": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "date",
                            "type": "Date",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 44,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "date",
                            "type": "Date",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "deleteMealProduct",
                    "args": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "typeofMeal",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "prodictId",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 52,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "typeofMeal",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "prodictId",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { DEFAULT_CURRENCY_CODE, Injectable, OnDestroy, OnInit, Output } from '@angular/core';\r\nimport { last, Subject, Subscription, takeUntil } from 'rxjs';\r\nimport { MealProduct } from '../models/mealproduct'\r\nimport { Meal, TypeOfMeal } from '../models/meal';\r\nimport { MealsController } from './meals.controller';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class MealsService {\r\n  mealId: number = 0;\r\n  public date = new Date;\r\n  breakfast: Array<MealProduct> = [];\r\n  lunch: Array<MealProduct> = [];\r\n  dinner: Array<MealProduct> = [];\r\n  snack: Array<MealProduct> = [];\r\n  meals: Array<Meal> = [];\r\n  meal!: Meal;\r\n  private readonly mealsController: MealsController;\r\n  private destroy$ = new Subject();\r\n\r\n\r\n  constructor(mealsController: MealsController) {\r\n    this.mealsController = mealsController;\r\n  }\r\n\r\n  addMeal(typeOfMeal: TypeOfMeal, date: Date, mealproducts: Array<MealProduct>): void {\r\n    if (this.date.toLocaleDateString() == date.toLocaleDateString() &&\r\n        this.meals.find(p => p.date.toLocaleDateString() == date.toLocaleDateString())\r\n        && this.meals.find(p=> p.type == typeOfMeal)) {\r\n\r\n      this.meals.find(p => p.date.toLocaleDateString() == date.toLocaleDateString()\r\n        && p.type == typeOfMeal)!.products = mealproducts;\r\n    }\r\n    else {\r\n      this.meal = { id: this.mealId, type: typeOfMeal, date: this.date, products: mealproducts }\r\n      this.meals.push(this.meal);\r\n      this.mealId++;\r\n    }\r\n    console.log(this.meals)\r\n    console.log(this.breakfast)\r\n  }\r\n\r\n  deleteMeal(id: number,date: Date): void {\r\n    let index = this.meals.findIndex( p =>p.products == this.breakfast );\r\n    this.meals.find(p =>p.products == this.breakfast && p.date.toLocaleDateString() == date.toLocaleDateString()\r\n     && p.products.find(m=> m.id == id))?.products.splice(index,1);\r\n    console.log(this.meals)\r\n    console.log(this.breakfast, \"delete\")\r\n  }\r\n\r\n  deleteMealProduct(id: number, typeofMeal: number, prodictId: number): void {\r\n    switch (typeofMeal) {\r\n      case 0:\r\n        this.deleteMeal(id, this.breakfast[0].date);\r\n        this.breakfast = this.breakfast.filter(p => p.id !== id);\r\n        break;\r\n      case 1:\r\n        this.deleteMeal(id, this.lunch[0].date);\r\n        this.lunch = this.lunch.filter(p => p.id !== id);\r\n        break;\r\n      case 2:\r\n        this.deleteMeal(id, this.dinner[0].date);\r\n        this.dinner = this.dinner.filter(p => p.id !== id);\r\n        break;\r\n      case 3:\r\n        this.deleteMeal(id, this.snack[0].date);\r\n        this.snack = this.snack.filter(p => p.id !== id);\r\n        break;\r\n    }\r\n  }\r\n\r\n  addMealProduct(mealProduct: MealProduct, type: TypeOfMeal): void {\r\n    switch (type) {\r\n      case 0:\r\n        this.breakfast.push(mealProduct);\r\n        this.addMeal(type, this.breakfast[0].date, this.breakfast)\r\n        break;\r\n      case 1:\r\n        this.lunch.push(mealProduct);\r\n        this.addMeal(type, this.lunch[0].date, this.lunch)\r\n        break;\r\n      case 2:\r\n        this.dinner.push(mealProduct);\r\n        this.addMeal(type, this.dinner[0].date, this.dinner)\r\n        break;\r\n      case 3:\r\n        this.snack.push(mealProduct);\r\n        this.addMeal(type, this.snack[0].date, this.snack)\r\n        break;\r\n    }\r\n  }\r\n\r\n}",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "mealsController",
                        "type": "MealsController",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 20,
                "jsdoctags": [
                    {
                        "name": "mealsController",
                        "type": "MealsController",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        },
        {
            "name": "ProductsService",
            "id": "injectable-ProductsService-79a308f4035c635e5b1863929d375c74644e7ac20489883524b93549ce3cb9874fcdb0e05159fbe027422d307061141dcf05652a99b489affc1c1bf37f3d9d33",
            "file": "src/app/services/products.service.ts",
            "properties": [
                {
                    "name": "apiClient",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ApiClient",
                    "optional": false,
                    "description": "",
                    "line": 9,
                    "modifierKind": [
                        121,
                        144
                    ]
                }
            ],
            "methods": [
                {
                    "name": "searchProducts",
                    "args": [
                        {
                            "name": "name",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<Product[]>",
                    "typeParameters": [],
                    "line": 15,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "name",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable } from '@angular/core';\r\nimport { map, Observable } from 'rxjs';\r\nimport { Product } from '../models/product';\r\nimport { ApiClient } from '../clients/api.client';\r\n\r\n@Injectable({providedIn: 'root'})\r\nexport class ProductsService {\r\n\r\n  private readonly apiClient: ApiClient;\r\n\r\n  constructor(apiClient: ApiClient) { \r\n    this.apiClient = apiClient;  \r\n  }\r\n\r\n  public searchProducts(name: string):Observable<Product[]> {\r\n    return this.apiClient\r\n      .find(name)\r\n      .pipe(map(response => response.map(dto => new Product(dto.id!, dto.name!, dto.calories!, dto.type!, dto.unit!))));\r\n  }\r\n}",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "apiClient",
                        "type": "ApiClient",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 9,
                "jsdoctags": [
                    {
                        "name": "apiClient",
                        "type": "ApiClient",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "type": "injectable"
        }
    ],
    "guards": [],
    "interceptors": [],
    "classes": [
        {
            "name": "ApiException",
            "id": "class-ApiException-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "message",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "status",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "response",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "headers",
                        "type": "literal type",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "result",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 918,
                "jsdoctags": [
                    {
                        "name": "message",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "status",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "response",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "headers",
                        "type": "literal type",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "result",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "headers",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "optional": false,
                    "description": "",
                    "line": 917
                },
                {
                    "name": "isApiException",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 930,
                    "modifierKind": [
                        122
                    ]
                },
                {
                    "name": "message",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 914,
                    "modifierKind": [
                        158
                    ]
                },
                {
                    "name": "response",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 916
                },
                {
                    "name": "result",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "optional": false,
                    "description": "",
                    "line": 918
                },
                {
                    "name": "status",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 915
                }
            ],
            "methods": [
                {
                    "name": "isApiException",
                    "args": [
                        {
                            "name": "obj",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "ApiException",
                    "typeParameters": [],
                    "line": 932,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        124
                    ],
                    "jsdoctags": [
                        {
                            "name": "obj",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": "Error",
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "ErrorDto",
            "id": "class-ErrorDto-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "data",
                        "type": "IErrorDto",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    }
                ],
                "line": 590,
                "jsdoctags": [
                    {
                        "name": "data",
                        "type": "IErrorDto",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "description",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 590
                }
            ],
            "methods": [
                {
                    "name": "fromJS",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "ErrorDto",
                    "typeParameters": [],
                    "line": 607,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        124
                    ],
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "init",
                    "args": [
                        {
                            "name": "_data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 601,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "_data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "toJSON",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 614,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "IErrorDto"
            ]
        },
        {
            "name": "LoginDto",
            "id": "class-LoginDto-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "data",
                        "type": "ILoginDto",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    }
                ],
                "line": 627,
                "jsdoctags": [
                    {
                        "name": "data",
                        "type": "ILoginDto",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "email",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 626
                },
                {
                    "name": "password",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 627
                }
            ],
            "methods": [
                {
                    "name": "fromJS",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "LoginDto",
                    "typeParameters": [],
                    "line": 645,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        124
                    ],
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "init",
                    "args": [
                        {
                            "name": "_data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 638,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "_data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "toJSON",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 652,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "ILoginDto"
            ]
        },
        {
            "name": "LoginResultDto",
            "id": "class-LoginResultDto-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "data",
                        "type": "ILoginResultDto",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    }
                ],
                "line": 673,
                "jsdoctags": [
                    {
                        "name": "data",
                        "type": "ILoginResultDto",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "error",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "LoginError",
                    "optional": true,
                    "description": "",
                    "line": 672
                },
                {
                    "name": "succeded",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "optional": true,
                    "description": "",
                    "line": 671
                },
                {
                    "name": "token",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 673
                }
            ],
            "methods": [
                {
                    "name": "fromJS",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "LoginResultDto",
                    "typeParameters": [],
                    "line": 692,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        124
                    ],
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "init",
                    "args": [
                        {
                            "name": "_data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 684,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "_data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "toJSON",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 699,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "ILoginResultDto"
            ]
        },
        {
            "name": "ProblemDetails",
            "id": "class-ProblemDetails-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "data",
                        "type": "IProblemDetails",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    }
                ],
                "line": 719,
                "jsdoctags": [
                    {
                        "name": "data",
                        "type": "IProblemDetails",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "detail",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 718
                },
                {
                    "name": "instance",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 719
                },
                {
                    "name": "status",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number | undefined",
                    "optional": true,
                    "description": "",
                    "line": 717
                },
                {
                    "name": "title",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 716
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 715
                }
            ],
            "methods": [
                {
                    "name": "fromJS",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "ProblemDetails",
                    "typeParameters": [],
                    "line": 740,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        124
                    ],
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "init",
                    "args": [
                        {
                            "name": "_data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 730,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "_data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "toJSON",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 747,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "IProblemDetails"
            ]
        },
        {
            "name": "Product",
            "id": "class-Product-0fe498eea47e368dc80c3d15fa9fbf570c85ebe998111db15fbc2bb0e4f5e68148072b62aa0126e096d44b7152bd6edc694cfb6efac034d083897bc7873af854",
            "file": "src/app/models/product.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "export class Product {\r\n    id: number;\r\n    name: string;\r\n    calories: number;\r\n    type: TypeofFood;\r\n    unit: unitType; \r\n    constructor(id: number, name: string, calories:number, type:number, unit:number){\r\n        this.id = id;\r\n        this.name = name;\r\n        this.calories = calories;\r\n        this.type = type;\r\n        this.unit = unit;\r\n    }\r\n}\r\n\r\nenum TypeofFood {\r\n    Meat,\r\n    Drink,\r\n    Cereal,\r\n    Vegetable,\r\n    Fruit,\r\n    Confection,\r\n    Bake,\r\n    Garnish, \r\n    Berrie, \r\n}\r\n\r\nenum unitType {\r\n    Milliliters,\r\n    Gram,\r\n    Pieces\r\n}",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "id",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "name",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "calories",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "type",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "unit",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 6,
                "jsdoctags": [
                    {
                        "name": "id",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "name",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "calories",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "type",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "unit",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "calories",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 4
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 2
                },
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 3
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TypeofFood",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "unit",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "unitType",
                    "optional": false,
                    "description": "",
                    "line": 6
                }
            ],
            "methods": [],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "ProductDto",
            "id": "class-ProductDto-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "data",
                        "type": "IProductDto",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    }
                ],
                "line": 771,
                "jsdoctags": [
                    {
                        "name": "data",
                        "type": "IProductDto",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "calories",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": true,
                    "description": "",
                    "line": 769
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": true,
                    "description": "",
                    "line": 767
                },
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 768
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": true,
                    "description": "",
                    "line": 770
                },
                {
                    "name": "unit",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": true,
                    "description": "",
                    "line": 771
                }
            ],
            "methods": [
                {
                    "name": "fromJS",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "ProductDto",
                    "typeParameters": [],
                    "line": 792,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        124
                    ],
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "init",
                    "args": [
                        {
                            "name": "_data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 782,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "_data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "toJSON",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 799,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "IProductDto"
            ]
        },
        {
            "name": "RegisterDto",
            "id": "class-RegisterDto-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "data",
                        "type": "IRegisterDto",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    }
                ],
                "line": 821,
                "jsdoctags": [
                    {
                        "name": "data",
                        "type": "IRegisterDto",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "email",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 820
                },
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 819
                },
                {
                    "name": "password",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 821
                }
            ],
            "methods": [
                {
                    "name": "fromJS",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "RegisterDto",
                    "typeParameters": [],
                    "line": 840,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        124
                    ],
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "init",
                    "args": [
                        {
                            "name": "_data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 832,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "_data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "toJSON",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 847,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "IRegisterDto"
            ]
        },
        {
            "name": "RegisterResultDto",
            "id": "class-RegisterResultDto-1723f7703f9e49054130505d1324bae147cd6fe271c990f5f05b2fb1f80d5c1471d464c311e56e20b4cb5413edbe1fed97a9db3fd21e480d0cef702d2c3530ab",
            "file": "src/app/clients/api.client.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable()\r\nexport class ApiClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    login(body: LoginDto | undefined): Observable<LoginResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/login-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processLogin(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processLogin(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<LoginResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<LoginResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = LoginResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    register(body: RegisterDto | undefined): Observable<RegisterResultDto> {\r\n        let url_ = this.baseUrl + \"/api/auth/register-page\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processRegister(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processRegister(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<RegisterResultDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<RegisterResultDto>;\r\n        }));\r\n    }\r\n\r\n    protected processRegister(response: HttpResponseBase): Observable<RegisterResultDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = RegisterResultDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    getProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Success\r\n     */\r\n    updateProduct(id: number, body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processUpdateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processUpdateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result200 = ProductDto.fromJS(resultData200);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return No Content\r\n     */\r\n    deleteProduct(id: number): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDeleteProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDeleteProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDeleteProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result204: any = null;\r\n            let resultData204 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result204 = ProductDto.fromJS(resultData204);\r\n            return _observableOf(result204);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 404) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result404: any = null;\r\n            let resultData404 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result404 = ErrorDto.fromJS(resultData404);\r\n            return throwException(\"Not Found\", status, _responseText, _headers, result404);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param name (optional)\r\n     * @return Success\r\n     */\r\n    find(name: string | undefined): Observable<ProductDto[]> {\r\n        let url_ = this.baseUrl + \"/api/products?\";\r\n        if (name === null)\r\n            throw new Error(\"The parameter 'name' cannot be null.\");\r\n        else if (name !== undefined)\r\n            url_ += \"name=\" + encodeURIComponent(\"\" + name) + \"&\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processFind(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processFind(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processFind(response: HttpResponseBase): Observable<ProductDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(ProductDto.fromJS(item));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional)\r\n     * @return Created\r\n     */\r\n    createProduct(body: ProductDto | undefined): Observable<ProductDto> {\r\n        let url_ = this.baseUrl + \"/api/products\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processCreateProduct(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processCreateProduct(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<ProductDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<ProductDto>;\r\n        }));\r\n    }\r\n\r\n    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 201) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result201: any = null;\r\n            let resultData201 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result201 = ProductDto.fromJS(resultData201);\r\n            return _observableOf(result201);\r\n            }));\r\n        } else if (status === 400) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result400: any = null;\r\n            let resultData400 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result400 = ErrorDto.fromJS(resultData400);\r\n            return throwException(\"Bad Request\", status, _responseText, _headers, result400);\r\n            }));\r\n        } else if (status === 401) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result401: any = null;\r\n            let resultData401 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result401 = ProblemDetails.fromJS(resultData401);\r\n            return throwException(\"Unauthorized\", status, _responseText, _headers, result401);\r\n            }));\r\n        } else if (status === 403) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result403: any = null;\r\n            let resultData403 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result403 = ProblemDetails.fromJS(resultData403);\r\n            return throwException(\"Forbidden\", status, _responseText, _headers, result403);\r\n            }));\r\n        } else if (status === 500) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result500: any = null;\r\n            let resultData500 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\r\n            result500 = ErrorDto.fromJS(resultData500);\r\n            return throwException(\"Server Error\", status, _responseText, _headers, result500);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class ErrorDto implements IErrorDto {\r\n    description?: string | undefined;\r\n\r\n    constructor(data?: IErrorDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.description = _data[\"description\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ErrorDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ErrorDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"description\"] = this.description;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IErrorDto {\r\n    description?: string | undefined;\r\n}\r\n\r\nexport class LoginDto implements ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: ILoginDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginDto {\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum LoginError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n}\r\n\r\nexport class LoginResultDto implements ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: ILoginResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): LoginResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new LoginResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface ILoginResultDto {\r\n    succeded?: boolean;\r\n    error?: LoginError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ProblemDetails implements IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n\r\n    constructor(data?: IProblemDetails) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.type = _data[\"type\"];\r\n            this.title = _data[\"title\"];\r\n            this.status = _data[\"status\"];\r\n            this.detail = _data[\"detail\"];\r\n            this.instance = _data[\"instance\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProblemDetails {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProblemDetails();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"type\"] = this.type;\r\n        data[\"title\"] = this.title;\r\n        data[\"status\"] = this.status;\r\n        data[\"detail\"] = this.detail;\r\n        data[\"instance\"] = this.instance;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProblemDetails {\r\n    type?: string | undefined;\r\n    title?: string | undefined;\r\n    status?: number | undefined;\r\n    detail?: string | undefined;\r\n    instance?: string | undefined;\r\n}\r\n\r\nexport class ProductDto implements IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n\r\n    constructor(data?: IProductDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            this.calories = _data[\"calories\"];\r\n            this.type = _data[\"type\"];\r\n            this.unit = _data[\"unit\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): ProductDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new ProductDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        data[\"calories\"] = this.calories;\r\n        data[\"type\"] = this.type;\r\n        data[\"unit\"] = this.unit;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IProductDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    calories?: number;\r\n    type?: number;\r\n    unit?: number;\r\n}\r\n\r\nexport class RegisterDto implements IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n\r\n    constructor(data?: IRegisterDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.name = _data[\"name\"];\r\n            this.email = _data[\"email\"];\r\n            this.password = _data[\"password\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"name\"] = this.name;\r\n        data[\"email\"] = this.email;\r\n        data[\"password\"] = this.password;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterDto {\r\n    name?: string | undefined;\r\n    email?: string | undefined;\r\n    password?: string | undefined;\r\n}\r\n\r\nexport enum RegisterError {\r\n    _0 = 0,\r\n    _1 = 1,\r\n    _2 = 2,\r\n    _3 = 3,\r\n}\r\n\r\nexport class RegisterResultDto implements IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n\r\n    constructor(data?: IRegisterResultDto) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any) {\r\n        if (_data) {\r\n            this.succeded = _data[\"succeded\"];\r\n            this.error = _data[\"error\"];\r\n            this.token = _data[\"token\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any): RegisterResultDto {\r\n        data = typeof data === 'object' ? data : {};\r\n        let result = new RegisterResultDto();\r\n        result.init(data);\r\n        return result;\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"succeded\"] = this.succeded;\r\n        data[\"error\"] = this.error;\r\n        data[\"token\"] = this.token;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IRegisterResultDto {\r\n    succeded?: boolean;\r\n    error?: RegisterError;\r\n    token?: string | undefined;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "data",
                        "type": "IRegisterResultDto",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    }
                ],
                "line": 872,
                "jsdoctags": [
                    {
                        "name": "data",
                        "type": "IRegisterResultDto",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "properties": [
                {
                    "name": "error",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "RegisterError",
                    "optional": true,
                    "description": "",
                    "line": 871
                },
                {
                    "name": "succeded",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "optional": true,
                    "description": "",
                    "line": 870
                },
                {
                    "name": "token",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "optional": true,
                    "description": "",
                    "line": 872
                }
            ],
            "methods": [
                {
                    "name": "fromJS",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "RegisterResultDto",
                    "typeParameters": [],
                    "line": 891,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        124
                    ],
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "init",
                    "args": [
                        {
                            "name": "_data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 883,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "_data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "toJSON",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 898,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "inputsClass": [],
            "outputsClass": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "IRegisterResultDto"
            ]
        }
    ],
    "directives": [],
    "components": [
        {
            "name": "AmountDialogComponent",
            "id": "component-AmountDialogComponent-58ffdd9e01a955992c948bc38de042de4802ea14ac55b2bd01082330c007a24ad78fd8ebc4ffb9fa649564a0d3034456692c7c94ee4d6182e1a40f61f5467be9",
            "file": "src/app/pages/body/meals-page/amount-dialog/amount-dialog.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-amount-dialog",
            "styleUrls": [
                "./amount-dialog.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./amount-dialog.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [
                {
                    "name": "accept",
                    "defaultValue": "new EventEmitter()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 20,
                    "type": "EventEmitter"
                },
                {
                    "name": "close",
                    "defaultValue": "new EventEmitter()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 19,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "amount",
                    "defaultValue": "1",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 9
                },
                {
                    "name": "containerRef",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ViewContainerRef",
                    "optional": false,
                    "description": "",
                    "line": 22,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "title",
                    "defaultValue": "'Enter the amount of food'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 18
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 26,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, EventEmitter, Inject, Input, OnInit, Output, ViewContainerRef } from '@angular/core';\r\n@Component({\r\n  selector: 'app-amount-dialog',\r\n  templateUrl: './amount-dialog.component.html',\r\n  styleUrls: ['./amount-dialog.component.scss']\r\n})\r\nexport class AmountDialogComponent implements OnInit {\r\n\r\n  amount:number = 1;\r\n  public set _amount(n :number){\r\n    if(n < 0 ){\r\n      this.amount = 1;\r\n    }\r\n    else{\r\n      this.amount =n;\r\n    }\r\n  }\r\n  title = 'Enter the amount of food';\r\n  @Output() close = new EventEmitter();\r\n  @Output() accept = new EventEmitter();\r\n  \r\n  constructor(public containerRef: ViewContainerRef) { \r\n    containerRef.clear();\r\n  }\r\n\r\n  ngOnInit(): void {\r\n  }\r\n}\r\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "\r\n.backdrop {\r\n    position:fixed;\r\n    top: 0;\r\n    bottom: 0;\r\n    right: 0;\r\n    left: 0;\r\n    background-color: rgba(0,0,0, .3);\r\n}\r\n.amount{\r\n    display: grid;\r\n    grid-row: 1fr 1fr 1fr;\r\n    padding: 1rem;\r\n    background-color: #fff;\r\n    margin-top: 3rem;\r\n    position: absolute;\r\n    left: 50%;\r\n    transform: translate(-50%, 100%);\r\n    border: solid 2px #64D36F;\r\n}\r\n.amount__buttons{\r\n    padding-top: 5px;\r\n    display: -moz-grid-line;\r\n    grid-column: 50% 50%;\r\n}\r\n.amount__buttons button{\r\n    width: 50%;\r\n}\r\nh1{\r\n    margin: 0px;\r\n}\r\n\r\n",
                    "styleUrl": "./amount-dialog.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "containerRef",
                        "type": "ViewContainerRef",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 20,
                "jsdoctags": [
                    {
                        "name": "containerRef",
                        "type": "ViewContainerRef",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit"
            ],
            "accessors": {
                "_amount": {
                    "name": "_amount",
                    "setSignature": {
                        "name": "_amount",
                        "type": "void",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "args": [
                            {
                                "name": "n",
                                "type": "number",
                                "deprecated": false,
                                "deprecationMessage": ""
                            }
                        ],
                        "returnType": "void",
                        "line": 10,
                        "jsdoctags": [
                            {
                                "name": "n",
                                "type": "number",
                                "deprecated": false,
                                "deprecationMessage": "",
                                "tagName": {
                                    "text": "param"
                                }
                            }
                        ]
                    }
                }
            },
            "templateData": "<div class=\"backdrop\"></div>\r\n<div class=\"amount\">\r\n    <h1>{{title}}</h1>\r\n    <input [(ngModel)]=\"_amount\" min=\"1\" type=\"number\" value=\"1\">\r\n    <div class=\"amount__buttons\">\r\n        <button (click)=\"close.emit()\">Close</button>\r\n        <button (click)=\"accept.emit()\">Accept</button>\r\n    </div>\r\n</div>"
        },
        {
            "name": "AppComponent",
            "id": "component-AppComponent-3035839885086d56496fa0c72dec618cffae5e2aa1f08ab940523b4d34aa48339ab326aaa00422227a10a47b899f9034ce271138c086d1e4675a917470a675cf",
            "file": "src/app/app.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-root",
            "styleUrls": [
                "./app.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./app.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "title",
                    "defaultValue": "'WeightControl'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 10
                }
            ],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component } from '@angular/core';\r\nimport { HeaderComponent } from './pages/header/header.component';\r\n\r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html',\r\n  styleUrls: ['./app.component.scss']\r\n})\r\nexport class AppComponent {\r\n  title = 'WeightControl';\r\n}\r\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".grid-container {\r\n    // border: solid 2px #000;\r\n    display: grid;\r\n    min-height: 100vh;\r\n    grid-template-areas: \"header header header header header\"\r\n                         \". . . . .\"\r\n                         \"menu . content . prompt\"\r\n                         \". . . . .\"\r\n                         \"footer footer footer footer footer\";\r\n    grid-template-columns: 1fr 5px 6fr 5px 1fr;\r\n    grid-template-rows: minmax(54px, auto) 5px 2fr 5px minmax(80px, auto);\r\n}\r\n\r\n.header { grid-area: header;}\r\n.menu { grid-area: menu;}\r\n.prompt { grid-area: prompt;}\r\n.content { grid-area: content;}\r\n.footer { grid-area: footer;}\r\n\r\n\r\n",
                    "styleUrl": "./app.component.scss"
                }
            ],
            "stylesData": "",
            "templateData": "<div class=\"grid-container\">\r\n    <div class=\"header\">\r\n        <app-header></app-header>\r\n    </div>\r\n    <div class=\"menu\">\r\n        <app-menu></app-menu>\r\n    </div>\r\n    <div class=\"content\">\r\n        <router-outlet></router-outlet>\r\n    </div>\r\n    <div class=\"prompt\">\r\n        <app-prompt></app-prompt>\r\n    </div>\r\n    <div class=\"footer\">\r\n        <app-footer></app-footer>\r\n    </div></div>"
        },
        {
            "name": "ButtonComponent",
            "id": "component-ButtonComponent-4ef205c97a334c309aa4001c8ab4a6d9571dcae18d0e85aaf0d367467ab5d3a9f13ab3573726f1fcb409bc9b49894dadfb80b1bbe1b6ba7041455ad9d4922004",
            "file": "src/stories/button.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "storybook-button",
            "styleUrls": [
                "./button.css"
            ],
            "styles": [],
            "template": "<button   type=\"button\"\n   (click)=\"onClick.emit($event)\"\n   [ngClass]=\"classes\"\n   [ngStyle]=\"{ 'background-color': backgroundColor }\"\n >\n   {{ label }}\n </button>",
            "templateUrl": [],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "backgroundColor",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nWhat background color to use\n",
                    "description": "<p>What background color to use</p>\n",
                    "line": 26,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "label",
                    "defaultValue": "'Button'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "pos": 711,
                            "end": 724,
                            "flags": 4227072,
                            "modifierFlagsCache": 0,
                            "transformFlags": 0,
                            "kind": 325,
                            "tagName": {
                                "pos": 712,
                                "end": 720,
                                "flags": 4227072,
                                "modifierFlagsCache": 0,
                                "transformFlags": 0,
                                "kind": 79,
                                "escapedText": "required"
                            },
                            "comment": ""
                        }
                    ],
                    "rawdescription": "\n\nButton contents\n\n",
                    "description": "<p>Button contents</p>\n",
                    "line": 40,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "primary",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nIs this the principal call to action on the page?\n",
                    "description": "<p>Is this the principal call to action on the page?</p>\n",
                    "line": 20,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "size",
                    "defaultValue": "'medium'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nHow large should the button be?\n",
                    "description": "<p>How large should the button be?</p>\n",
                    "line": 32,
                    "type": "\"small\" | \"medium\" | \"large\"",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "onClick",
                    "defaultValue": "new EventEmitter<Event>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nOptional click handler\n",
                    "description": "<p>Optional click handler</p>\n",
                    "line": 46,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'storybook-button',\n  template: ` <button\n    type=\"button\"\n    (click)=\"onClick.emit($event)\"\n    [ngClass]=\"classes\"\n    [ngStyle]=\"{ 'background-color': backgroundColor }\"\n  >\n    {{ label }}\n  </button>`,\n  styleUrls: ['./button.css'],\n})\nexport default class ButtonComponent {\n  /**\n   * Is this the principal call to action on the page?\n   */\n  @Input()\n  primary = false;\n\n  /**\n   * What background color to use\n   */\n  @Input()\n  backgroundColor?: string;\n\n  /**\n   * How large should the button be?\n   */\n  @Input()\n  size: 'small' | 'medium' | 'large' = 'medium';\n\n  /**\n   * Button contents\n   *\n   * @required\n   */\n  @Input()\n  label = 'Button';\n\n  /**\n   * Optional click handler\n   */\n  @Output()\n  onClick = new EventEmitter<Event>();\n\n  public get classes(): string[] {\n    const mode = this.primary ? 'storybook-button--primary' : 'storybook-button--secondary';\n\n    return ['storybook-button', `storybook-button--${this.size}`, mode];\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".storybook-button {\n  font-family: 'Nunito Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\n  font-weight: 700;\n  border: 0;\n  border-radius: 3em;\n  cursor: pointer;\n  display: inline-block;\n  line-height: 1;\n}\n.storybook-button--primary {\n  color: white;\n  background-color: #1ea7fd;\n}\n.storybook-button--secondary {\n  color: #333;\n  background-color: transparent;\n  box-shadow: rgba(0, 0, 0, 0.15) 0px 0px 0px 1px inset;\n}\n.storybook-button--small {\n  font-size: 12px;\n  padding: 10px 16px;\n}\n.storybook-button--medium {\n  font-size: 14px;\n  padding: 11px 20px;\n}\n.storybook-button--large {\n  font-size: 16px;\n  padding: 12px 24px;\n}\n",
                    "styleUrl": "./button.css"
                }
            ],
            "stylesData": "",
            "accessors": {
                "classes": {
                    "name": "classes",
                    "getSignature": {
                        "name": "classes",
                        "type": "[]",
                        "returnType": "string[]",
                        "line": 48
                    }
                }
            }
        },
        {
            "name": "FooterComponent",
            "id": "component-FooterComponent-6c290628b84a1abe1bdfb878464bc2b706fefca858c51621202ab34ffddd486d19c7b04ea6e2c5d71d1bb1dffcb9099de70b3a4f92b6e5c31ebf472a97986eb5",
            "file": "src/app/pages/footer/footer.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-footer",
            "styleUrls": [
                "./footer.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./footer.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 12,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'app-footer',\r\n  templateUrl: './footer.component.html',\r\n  styleUrls: ['./footer.component.scss']\r\n})\r\nexport class FooterComponent implements OnInit {\r\n\r\n  constructor() { }\r\n\r\n  ngOnInit(): void {\r\n  }\r\n\r\n}\r\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".footer {\r\n    grid-area: footer;\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr 1fr;\r\n    margin: 0px;\r\n    border-top: #64D36F 1px solid;\r\n    justify-content: center;\r\n    height: 99%;\r\n}\r\n\r\n.footer__content {\r\n    display: grid;\r\n    align-items: center;\r\n    justify-content: center;\r\n    text-align: center;\r\n\r\n}\r\n\r\np {\r\n    margin: 0;\r\n}\r\n\r\na {\r\n    margin: 0;\r\n}",
                    "styleUrl": "./footer.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 8
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<footer class=\"footer\">\r\n    <p class=\"footer__content\">Lorem ipsum dolor sit amet consectetur adipisicing elit. Ut hic dolores iusto nam sint unde\r\n        labore.\r\n        Asperiores provident repudiandae ullam aperiam necessitatibus ipsa architecto deserunt dignissimos?\r\n        Molestias exercitationem autem aut!</p>\r\n    <a class=\"footer__content\" href=\"https://github.com/ZaytsevGleb/WeightControl\">Project Link</a>\r\n    <p class=\"footer__content\">Lorem ipsum dolor sit, amet consectetur adipisicing elit. Maxime praesentium aut\r\n        consectetur assumenda?\r\n        Adipisci reiciendis atque veritatis ipsa laudantium illo, illum in? Animi itaque nam repellat dolorem,\r\n        ducimus ipsa nostrum!</p>\r\n</footer>"
        },
        {
            "name": "GoalsPageComponent",
            "id": "component-GoalsPageComponent-67058ae37a0a1b3d1d1223c353b481c5fd3a88da1e4e62ec36e71c3fd9fa2edeb307f14f85fff150faed63737df5e2972bc5aff76dedbc4b12f226fde6b97733",
            "file": "src/app/pages/body/goals-page/goals-page.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-goals-page",
            "styleUrls": [
                "./goals-page.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./goals-page.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 12,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'app-goals-page',\r\n  templateUrl: './goals-page.component.html',\r\n  styleUrls: ['./goals-page.component.scss']\r\n})\r\nexport class GoalsPageComponent implements OnInit {\r\n\r\n  constructor() { }\r\n\r\n  ngOnInit(): void {\r\n  }\r\n\r\n}\r\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./goals-page.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 8
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<h1>Goals Page</h1>"
        },
        {
            "name": "HeaderComponent",
            "id": "component-HeaderComponent-a557eec14f72c438a8033301f4d6ce023e0a1844a3b06ec2b38794a612acc31735ae78a5ee10071b230c8c20d699eb914554e69d07ade54adb371da8efb464cc",
            "file": "src/stories/header.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "storybook-header",
            "styleUrls": [
                "./header.css"
            ],
            "styles": [],
            "template": "<header>    <div class=\"wrapper\">\n      <div>\n        <svg width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" xmlns=\"http://www.w3.org/2000/svg\">\n          <g fill=\"none\" fillRule=\"evenodd\">\n            <path\n              d=\"M10 0h12a10 10 0 0110 10v12a10 10 0 01-10 10H10A10 10 0 010 22V10A10 10 0 0110 0z\"\n              fill=\"#FFF\"\n            />\n            <path\n              d=\"M5.3 10.6l10.4 6v11.1l-10.4-6v-11zm11.4-6.2l9.7 5.5-9.7 5.6V4.4z\"\n              fill=\"#555AB9\"\n            />\n            <path\n              d=\"M27.2 10.6v11.2l-10.5 6V16.5l10.5-6zM15.7 4.4v11L6 10l9.7-5.5z\"\n              fill=\"#91BAF8\"\n            />\n          </g>\n        </svg>\n        <h1>Acme</h1>\n      </div>\n      <div>\n        <div *ngIf=\"user\">\n          <span class=\"welcome\">\n            Welcome, <b>{{ user.name }}</b\n            >!\n          </span>\n          <storybook-button\n            *ngIf=\"user\"\n            size=\"small\"\n            (onClick)=\"onLogout.emit($event)\"\n            label=\"Log out\"\n          ></storybook-button>\n        </div>\n        <div *ngIf=\"!user\">\n          <storybook-button\n            *ngIf=\"!user\"\n            size=\"small\"\n            class=\"margin-left\"\n            (onClick)=\"onLogin.emit($event)\"\n            label=\"Log in\"\n          ></storybook-button>\n          <storybook-button\n            *ngIf=\"!user\"\n            primary\n            size=\"small\"\n            primary=\"true\"\n            class=\"margin-left\"\n            (onClick)=\"onCreateAccount.emit($event)\"\n            label=\"Sign up\"\n          ></storybook-button>\n        </div>\n      </div>\n    </div>\n  </header>",
            "templateUrl": [],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "user",
                    "defaultValue": "null",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 65,
                    "type": "User | null",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "onCreateAccount",
                    "defaultValue": "new EventEmitter<Event>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 74,
                    "type": "EventEmitter"
                },
                {
                    "name": "onLogin",
                    "defaultValue": "new EventEmitter<Event>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 68,
                    "type": "EventEmitter"
                },
                {
                    "name": "onLogout",
                    "defaultValue": "new EventEmitter<Event>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 71,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { User } from './User';\n\n@Component({\n  selector: 'storybook-header',\n  template: `<header>\n    <div class=\"wrapper\">\n      <div>\n        <svg width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" xmlns=\"http://www.w3.org/2000/svg\">\n          <g fill=\"none\" fillRule=\"evenodd\">\n            <path\n              d=\"M10 0h12a10 10 0 0110 10v12a10 10 0 01-10 10H10A10 10 0 010 22V10A10 10 0 0110 0z\"\n              fill=\"#FFF\"\n            />\n            <path\n              d=\"M5.3 10.6l10.4 6v11.1l-10.4-6v-11zm11.4-6.2l9.7 5.5-9.7 5.6V4.4z\"\n              fill=\"#555AB9\"\n            />\n            <path\n              d=\"M27.2 10.6v11.2l-10.5 6V16.5l10.5-6zM15.7 4.4v11L6 10l9.7-5.5z\"\n              fill=\"#91BAF8\"\n            />\n          </g>\n        </svg>\n        <h1>Acme</h1>\n      </div>\n      <div>\n        <div *ngIf=\"user\">\n          <span class=\"welcome\">\n            Welcome, <b>{{ user.name }}</b\n            >!\n          </span>\n          <storybook-button\n            *ngIf=\"user\"\n            size=\"small\"\n            (onClick)=\"onLogout.emit($event)\"\n            label=\"Log out\"\n          ></storybook-button>\n        </div>\n        <div *ngIf=\"!user\">\n          <storybook-button\n            *ngIf=\"!user\"\n            size=\"small\"\n            class=\"margin-left\"\n            (onClick)=\"onLogin.emit($event)\"\n            label=\"Log in\"\n          ></storybook-button>\n          <storybook-button\n            *ngIf=\"!user\"\n            primary\n            size=\"small\"\n            primary=\"true\"\n            class=\"margin-left\"\n            (onClick)=\"onCreateAccount.emit($event)\"\n            label=\"Sign up\"\n          ></storybook-button>\n        </div>\n      </div>\n    </div>\n  </header>`,\n  styleUrls: ['./header.css'],\n})\nexport default class HeaderComponent {\n  @Input()\n  user: User | null = null;\n\n  @Output()\n  onLogin = new EventEmitter<Event>();\n\n  @Output()\n  onLogout = new EventEmitter<Event>();\n\n  @Output()\n  onCreateAccount = new EventEmitter<Event>();\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".wrapper {\n  font-family: 'Nunito Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.1);\n  padding: 15px 20px;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\nsvg {\n  display: inline-block;\n  vertical-align: top;\n}\n\nh1 {\n  font-weight: 900;\n  font-size: 20px;\n  line-height: 1;\n  margin: 6px 0 6px 10px;\n  display: inline-block;\n  vertical-align: top;\n}\n\nbutton + button {\n  margin-left: 10px;\n}\n\n.welcome {\n  color: #333;\n  font-size: 14px;\n  margin-right: 10px;\n}\n",
                    "styleUrl": "./header.css"
                }
            ],
            "stylesData": ""
        },
        {
            "name": "HeaderComponent",
            "id": "component-HeaderComponent-084608a31b4a886b9d8ca4e1a133a07bf9bbab7a019595760ee6a6455be36e2f087fc55d31000713c6c70e9905d400f9eeee543aacef2dbcbedd68ccd511b612-1",
            "file": "src/app/pages/header/header.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-header",
            "styleUrls": [
                "./header.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./header.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 13,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\r\nimport { AppComponent } from 'src/app/app.component';\r\n\r\n@Component({\r\n  selector: 'app-header',\r\n  templateUrl: './header.component.html',\r\n  styleUrls: ['./header.component.scss']\r\n})\r\nexport class HeaderComponent implements OnInit {\r\n\r\n  constructor() { }\r\n\r\n  ngOnInit(): void {\r\n  }\r\n\r\n}\r\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".header {\r\n    grid-area: header;\r\n    display: grid;\r\n    background-color: #D9D9D9;\r\n    grid-template-columns: 1fr  6fr 1fr;\r\n    align-items: center;\r\n    padding: 15px 0px;\r\n    border: #64D36F 1px solid;\r\n    margin: 0px;\r\n}\r\n.header__logo {\r\n\r\n    margin: 0px;\r\n    font-weight: 400;\r\n    font-size: 28px;\r\n    grid-column: 1/3;\r\n    padding-left: 15px;\r\n}\r\n.header__logo a{\r\n    font-size: 28px;\r\n}\r\n.header__links{\r\n    display: grid;\r\n    grid-column: 3/3;\r\n    grid-auto-flow: column;\r\n    justify-items: center;\r\n\r\n}\r\n.header__links a{\r\n    font-size: 18px;\r\n}\r\n",
                    "styleUrl": "./header.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 9
            },
            "implements": [
                "OnInit"
            ],
            "isDuplicate": true,
            "duplicateId": 1,
            "duplicateName": "HeaderComponent-1",
            "templateData": "<header class=\"header\">\r\n        <h1 class=\"header__logo\"><a href=\"#\">WeightControl</a></h1>\r\n        <div class=\"header__links\">\r\n            <a class=\"header__login\" href=\"\" routerLink=\"/login\">Login</a>\r\n            <a class=\"header__signup\" href=\"\" routerLink=\"/register\">Register</a>\r\n        </div>\r\n</header>\r\n"
        },
        {
            "name": "HelpPageComponent",
            "id": "component-HelpPageComponent-45ea05ecab636fce2f48dcf4587976bfd917993a12385c004c05c4119a334cfc1a1d0e4b6327152d8020af8f814367bf9259f9718986331ce830b7b8ab2b2d18",
            "file": "src/app/pages/body/help-page/help-page.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-help-page",
            "styleUrls": [
                "./help-page.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./help-page.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 12,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'app-help-page',\r\n  templateUrl: './help-page.component.html',\r\n  styleUrls: ['./help-page.component.scss']\r\n})\r\nexport class HelpPageComponent implements OnInit {\r\n\r\n  constructor() { }\r\n\r\n  ngOnInit(): void {\r\n  }\r\n\r\n}\r\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./help-page.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 8
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<h1>Help Page</h1>"
        },
        {
            "name": "LoginPageComponent",
            "id": "component-LoginPageComponent-f8269ea832b9f0601b94dda36c66b4d202c31308ed67ac4c5762dfbbbc8af1e493bca30126a3f5c3726976e92bc5c9be531290634816b3d5e46d61be6c4f1ff9",
            "file": "src/app/pages/body/login-page/login-page.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-login-page",
            "styleUrls": [
                "./login-page.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./login-page.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 12,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'app-login-page',\r\n  templateUrl: './login-page.component.html',\r\n  styleUrls: ['./login-page.component.scss']\r\n})\r\nexport class LoginPageComponent implements OnInit {\r\n\r\n  constructor() { }\r\n\r\n  ngOnInit(): void {\r\n  }\r\n\r\n}\r\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "a, p{\r\n  padding: 0;\r\n  margin: 0;\r\n}\r\n*{\r\n  font-family: 'Ubuntu', sans-serif;\r\n}\r\n.login__page{\r\n  grid-area: login-page;\r\n  display: grid;\r\n  height: 100%;\r\n  width: 100%;\r\n  grid-template: 1fr 2.5fr 1fr / 1.4fr 1fr 1.4fr;\r\n}\r\n\r\n.login__window{\r\n  display: grid;\r\n  grid-column: 2/3;\r\n  grid-row: 2/3;\r\n  height: 100%;\r\n  grid-template: 1fr 3fr 1fr / 1fr 5fr 1fr;\r\n  border-radius: 20px;\r\n  box-shadow: 0 3px 20px 0 rgba(0, 0, 0, 0.1);\r\n}\r\n\r\n.login__header{\r\n  display: grid;\r\n  grid-column: 1/4;\r\n  grid-row: 1/1;\r\n  justify-items: center;\r\n  align-items: center;\r\n  background-color: #64D36F;\r\n  border-radius: 20px 20px 0 0;\r\n}\r\n\r\n.login__header h2{\r\n  margin: 0;\r\n  padding: 0;\r\n  color: white;\r\n  font-weight: bold;\r\n  font-family: 'Ubuntu', sans-serif;\r\n}\r\n\r\n.login__body{\r\n  display: grid;\r\n  grid-row: 2/3;\r\n  grid-column: 2/3;\r\n  grid-template: 1fr 1fr 1fr 1fr 1fr 1fr / 1fr;\r\n  row-gap: 10px;\r\n}\r\n\r\n.login__body input{\r\n  width: 100%;\r\n  height: 100%;\r\n  margin: 0;\r\n  padding: 0;\r\n  border: none;\r\n  border-radius: 20px;\r\n  background-color: #ebebeb;\r\n  text-indent: 10px;\r\n  color: #1b3815;\r\n}\r\n\r\ninput::-webkit-input-placeholder { color: #1b3815;}\r\ninput:-moz-placeholder { color: #1b3815;}\r\ninput::-moz-placeholder { color: #1b3815;}\r\ninput:-ms-input-placeholder { color: #1b3815;}\r\n\r\ninput:active, :hover, :focus {\r\n  outline: 0;\r\n  outline-offset: 0;\r\n}\r\n\r\n.input__email{\r\n  display: grid;\r\n  grid-row: 2/3;\r\n}\r\n\r\n.input__password{\r\n  display: grid;\r\n  grid-row: 3/4;\r\n}\r\n\r\n.login__body button{\r\n  align-items: center;\r\n  color: white;\r\n  font-weight: bold;\r\n}\r\n\r\n.button__login{\r\n  display: grid;\r\n  grid-row: 5/6;\r\n  background-color: #64D36F;\r\n  border-radius: 20px;\r\n  border: none;\r\n}\r\n\r\nbutton:hover{\r\n  background-color: #1b3815;\r\n  transition: all 0.5s;\r\n}\r\n\r\n.login__footer{\r\n  display: grid;\r\n  grid-column: 2/3;\r\n  grid-row: 3/3;\r\n  justify-content: center;\r\n}\r\n\r\n.login__footer p{\r\n  display: grid;\r\n  align-items: end;\r\n  color: #999;\r\n}\r\n\r\n.login__footer a{\r\n  text-align: center;\r\n  color: #64D36F;\r\n}\r\n\r\n.login__footer a:hover{\r\n  text-decoration: none;\r\n  color: #1b3815;\r\n  transition: all 0.5s;\r\n}\r\n\r\n",
                    "styleUrl": "./login-page.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 8
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<div class=\"login__page\">\r\n  <div class=\"login__window\">\r\n      <div class=\"login__header\">\r\n        <h2>\r\n          Login\r\n        </h2>\r\n      </div>\r\n      <div class=\"login__body\">\r\n        <input type=\"email\" class=\"input__email\" placeholder=\"Email\" >\r\n        <input type=\"password\" class=\"input__password\" placeholder=\"Password\">\r\n        <button type=\"button\" class=\"button__login\">LOGIN</button>\r\n      </div>\r\n      <div class=\"login__footer\">\r\n        <p>Don't have an account?</p>\r\n        <a routerLink=\"/register\">Register now</a>\r\n      </div>\r\n  </div>\r\n</div>\r\n"
        },
        {
            "name": "MealsPageComponent",
            "id": "component-MealsPageComponent-31ab239229c69b4b3dd4fb09457dabfdb22da860125cd64c89f9d88d47f59af034f945d43958f3c45d184f61b91c3c918594254a27fd0d47cce1f4a12e4107e5",
            "file": "src/app/pages/body/meals-page/meals-page.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-meals-page",
            "styleUrls": [
                "./meals-page.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./meals-page.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 11,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component,  OnInit } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'app-meals-page',\r\n  templateUrl: './meals-page.component.html',\r\n  styleUrls: ['./meals-page.component.scss']\r\n})\r\nexport class MealsPageComponent implements OnInit {\r\n\r\n  constructor() { }\r\n  ngOnInit(): void {\r\n  }\r\n\r\n}\r\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".meals{\r\n    // border: solid 2px #000;\r\n    display: grid;\r\n    grid-template-areas: \"header header header\"\r\n                         \"meals-part . products-part\";\r\n    grid-template-columns: 1fr 5px 1fr;\r\n    grid-template-rows: 50px 1fr;\r\n    height: 100%;\r\n}\r\n\r\n.meals__header {\r\n    grid-area: header;\r\n    border: #64D36F 1px solid;\r\n    display: grid;\r\n    justify-content: start;\r\n    padding: 10px;\r\n\r\n}\r\n\r\n.meals__header h1 {\r\n     font-size: 26px;\r\n     font-weight:500;\r\n     margin: 0px;\r\n }\r\n\r\n.meals__part {\r\n    grid-area: meals-part;\r\n}\r\n\r\n.products__part {\r\n    grid-area: products-part;\r\n    border-left: #64D36F 1px solid;\r\n    border-right: #64D36F 1px solid;\r\n    border-bottom: #64D36F 1px solid;\r\n}\r\n.meals__part {\r\n    border-left:  #64D36F 1px solid;\r\n    border-right: #64D36F 1px solid;\r\n    border-bottom: #64D36F 1px solid;\r\n}\r\n",
                    "styleUrl": "./meals-page.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 8
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<div class=\"meals\">\r\n    <div class=\"meals__header\">\r\n        <h1>Meals</h1>\r\n    </div>\r\n    <div class=\"meals__part\">\r\n        <app-meals-part></app-meals-part>\r\n    </div>\r\n    <div class=\"products__part\">\r\n        <app-products-part></app-products-part>\r\n    </div>\r\n    \r\n</div>"
        },
        {
            "name": "MealsPartComponent",
            "id": "component-MealsPartComponent-eed3552bc19900cee2db1db026499f502374d23c82f9cb51c60078ecddcb3d0673ccc651a757d97e3192f8bb882be3bfce142b30c7b3b961b54577e49516c8f3",
            "file": "src/app/pages/body/meals-page/meals-part/meals-part.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-meals-part",
            "styleUrls": [
                "./meals-part.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./meals-part.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "breakfast",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<MealProduct>",
                    "optional": false,
                    "description": "",
                    "line": 20
                },
                {
                    "name": "date",
                    "defaultValue": "new Date",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "destroy$",
                    "defaultValue": "new Subject()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 27,
                    "modifierKind": [
                        121
                    ]
                },
                {
                    "name": "dinner",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<MealProduct>",
                    "optional": false,
                    "description": "",
                    "line": 22
                },
                {
                    "name": "lunch",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<MealProduct>",
                    "optional": false,
                    "description": "",
                    "line": 21
                },
                {
                    "name": "mealproductId",
                    "defaultValue": "0",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 26,
                    "modifierKind": [
                        121
                    ]
                },
                {
                    "name": "mealsController",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MealsController",
                    "optional": false,
                    "description": "",
                    "line": 28,
                    "modifierKind": [
                        121,
                        144
                    ]
                },
                {
                    "name": "mealsService",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MealsService",
                    "optional": false,
                    "description": "",
                    "line": 30,
                    "modifierKind": [
                        121,
                        144
                    ]
                },
                {
                    "name": "product",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Product",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "products",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<Product>",
                    "optional": false,
                    "description": "",
                    "line": 19
                },
                {
                    "name": "productService",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ProductsService",
                    "optional": false,
                    "description": "",
                    "line": 29,
                    "modifierKind": [
                        121,
                        144
                    ]
                },
                {
                    "name": "snack",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<MealProduct>",
                    "optional": false,
                    "description": "",
                    "line": 23
                }
            ],
            "methodsClass": [
                {
                    "name": "addProduct",
                    "args": [
                        {
                            "name": "params",
                            "type": "SelectedProductParams",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 59,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        121
                    ],
                    "jsdoctags": [
                        {
                            "name": "params",
                            "type": "SelectedProductParams",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "deleteMealProduct",
                    "args": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "typeofMeal",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "productId",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 67,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "typeofMeal",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "productId",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngDoCheck",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 38,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnDestroy",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 50,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 45,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "setAmount",
                    "args": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 102,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "showProductCalories",
                    "args": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 80,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "showProductName",
                    "args": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 74,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "showProducts",
                    "args": [
                        {
                            "name": "typeofMeal",
                            "type": "TypeOfMeal",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 55,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "typeofMeal",
                            "type": "TypeOfMeal",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "showProductUnit",
                    "args": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 85,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, DoCheck, OnDestroy, OnInit } from '@angular/core';\r\nimport { Meal, TypeOfMeal } from 'src/app/models/meal';\r\nimport { MealsController } from 'src/app/services/meals.controller';\r\nimport { SelectedProductParams } from 'src/app/models/selected-product-params';\r\nimport { ProductsService } from 'src/app/services/products.service';\r\nimport { Subject, takeUntil } from 'rxjs';\r\nimport { MealsService } from 'src/app/services/meals.service';\r\nimport { Product } from 'src/app/models/product';\r\nimport { MealProduct } from 'src/app/models/mealproduct';\r\n\r\n@Component({\r\n  selector: 'app-meals-part',\r\n  templateUrl: './meals-part.component.html',\r\n  styleUrls: ['./meals-part.component.scss']\r\n})\r\nexport class MealsPartComponent implements OnInit, OnDestroy, DoCheck {\r\n  product!: Product;\r\n  public date = new Date;\r\n  products: Array<Product> = [];\r\n  breakfast: Array<MealProduct> = [];\r\n  lunch: Array<MealProduct> = [];\r\n  dinner: Array<MealProduct> = [];\r\n  snack: Array<MealProduct> = [];\r\n\r\n\r\n  private mealproductId: number = 0;\r\n  private destroy$ = new Subject();\r\n  private readonly mealsController: MealsController;\r\n  private readonly productService: ProductsService\r\n  private readonly mealsService: MealsService;\r\n\r\n  constructor(mealsController: MealsController, productService: ProductsService, mealsService: MealsService) {\r\n    this.mealsController = mealsController;\r\n    this.productService = productService;\r\n    this.mealsService = mealsService;\r\n  }\r\n\r\n  ngDoCheck(): void {\r\n    this.breakfast = this.mealsService.breakfast;\r\n    this.lunch = this.mealsService.lunch;\r\n    this.dinner = this.mealsService.dinner;\r\n    this.snack = this.mealsService.snack;\r\n  }\r\n\r\n  ngOnInit(): void {\r\n    this.mealsController.porductSelected$.pipe(takeUntil(this.destroy$))\r\n    .subscribe(params => this.addProduct(params));\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this.destroy$.next(true);\r\n    this.destroy$.complete();\r\n  }\r\n\r\n  public showProducts(typeofMeal: TypeOfMeal): void {\r\n    this.mealsController.setFocus(typeofMeal);\r\n  }\r\n\r\n  private addProduct(params: SelectedProductParams): void {\r\n    this.product = params.product;\r\n    this.products.push(this.product);\r\n    let mealProduct: MealProduct = { id: this.mealproductId, productId: this.product.id, date: this.date, amount: params.amount }\r\n    this.mealproductId++;\r\n    this.mealsService.addMealProduct(mealProduct, params.typeofMeal);\r\n  }\r\n\r\n  deleteMealProduct(id: number, typeofMeal: number, productId: number): void {\r\n    this.mealsService.deleteMealProduct(id, typeofMeal, productId);\r\n    // this.products = this.products.filter(p => p.id !== productId, 1);\r\n    let index = this.products.findIndex(p => p.id ==productId);\r\n    this.products.splice(index, 1);\r\n  }\r\n  //  -,       ,       \r\n  showProductName(id: number): string {\r\n    let value = this.products.find(p => p.id == id)!;\r\n      return value.name;\r\n    \r\n  }\r\n\r\n  showProductCalories(id: number, amount: number): number {\r\n    let value = this.products.find(p => p.id == id)!;\r\n    return value.calories * amount;\r\n  }\r\n  //     Subject    product-part\r\n  showProductUnit(id: number): string {\r\n    let value = this.products.find(p => p.id == id)!;\r\n    switch (value.unit) {\r\n      case 0:\r\n        return \"Milliliters\"\r\n        break;\r\n      case 1:\r\n        return \"Gram\"\r\n        break;\r\n      case 2:\r\n        return \"Pieces\"\r\n        break;\r\n      default:\r\n        return \"\";\r\n        break;\r\n    }\r\n  }\r\n  setAmount(id: number, amount: number): number {\r\n    let value = this.products.find(p => p.id == id)!;\r\n    switch (value.unit) {\r\n      case 0:\r\n        return 100 * amount;\r\n        break;\r\n      case 1:\r\n        return 100 * amount;\r\n        break;\r\n      case 2:\r\n        return 1 * amount;\r\n        break;\r\n      default:\r\n        return 0;\r\n        break;\r\n    }\r\n  }\r\n}\r\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".meals__part {\r\n    grid-area: meals-part;\r\n    display: grid;\r\n    height: 100%;\r\n    margin: 0px;\r\n    padding: 0px;\r\n    grid-template-rows: 1fr 13fr;\r\n}\r\n\r\n.mealspart__header {\r\n    display: grid;\r\n    grid-template: 1fr / 2fr 1fr 1fr;\r\n    align-items: center;\r\n}\r\n\r\n.mealspart__header h2 {\r\n    font-size: 0.9vw;\r\n    margin: 0px;\r\n    padding: 5px 10px;\r\n    background-color: #D9D9D9;\r\n    border: 1px solid #64D36F;\r\n}\r\n\r\n.mealspart__calories {\r\n    display: grid;\r\n    grid-column: 2/3;\r\n    justify-content: end;\r\n}\r\n\r\n\r\n.mealspart__date {\r\n    display: grid;\r\n    grid-column: 3/3;\r\n    justify-content: end;\r\n    padding-right: 20px;\r\n}\r\n\r\n// MEALS\r\n// .meals {}\r\n\r\n.meals h3 {\r\n    margin: 0px;\r\n}\r\n\r\n.mealspart__list {\r\n    margin: 20px;\r\n    padding: 0px;\r\n}\r\n\r\n.mealpart__header {\r\n    margin-top: 20px;\r\n    margin-bottom: 5px;\r\n    display: grid;\r\n    grid-template-columns: 1.2fr 1fr 7fr;\r\n}\r\n\r\n.mealspart__button {\r\n    display: grid;\r\n    grid-column: 2/3;\r\n    justify-items: center;\r\n}\r\n\r\n.mealpart__header h3 {\r\n    font-size: 20px;\r\n}\r\n\r\n.mealpart__main {\r\n    display: grid;\r\n}\r\n\r\n.mealpart__info {\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr 1fr 1fr;\r\n    padding: 7px;\r\n    padding-left: 20px;\r\n    margin-bottom: 10px;\r\n    background-color: #D9D9D9;\r\n    border: 1px solid #64D36F;\r\n}\r\n",
                    "styleUrl": "./meals-part.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "mealsController",
                        "type": "MealsController",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "productService",
                        "type": "ProductsService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "mealsService",
                        "type": "MealsService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 30,
                "jsdoctags": [
                    {
                        "name": "mealsController",
                        "type": "MealsController",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "productService",
                        "type": "ProductsService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "mealsService",
                        "type": "MealsService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit",
                "OnDestroy",
                "DoCheck"
            ],
            "templateData": "<div class=\"meals__part\">\r\n    <div class=\"mealspart__header\">\r\n        <div class=\"mealspart__calories\">\r\n            <h2>1700/2000</h2>\r\n        </div>\r\n\r\n        <div class=\"mealspart__date\">\r\n            <h2>{{date | date: 'mediumDate'}}</h2>\r\n        </div>\r\n    </div>\r\n    <div class=\"meals\">\r\n        <ul class=\"mealspart__list\">\r\n            <li class=\"mealpart__header\">\r\n                <h3>Breakfast</h3>\r\n                <div class=\"mealspart__button\">\r\n                    <button (click)=\"showProducts(0)\">add</button>\r\n                </div>\r\n            </li>\r\n            <li class=\"mealpart__main\" *ngFor=\"let b of breakfast\">\r\n                <ul class=\"mealpart__info\">\r\n                    <li>{{showProductName(b.productId)}}</li>\r\n                    <li>Calories: {{showProductCalories(b.productId, b.amount)}}</li>\r\n                    <li>{{showProductUnit(b.productId)}}: {{setAmount(b.productId,b.amount)}}</li>\r\n                    <li><button (click)=\"deleteMealProduct(b.id, 0, b.productId)\">delete</button></li>\r\n                </ul>\r\n            </li>\r\n            <li class=\"mealpart__header\">\r\n                <h3>Lunch</h3>\r\n                <div class=\"mealspart__button\">\r\n                    <button (click)=\"showProducts(1)\">add</button>\r\n                </div>\r\n            </li>\r\n            <li class=\"mealpart__main\" *ngFor=\"let l of lunch\">\r\n                <ul class=\"mealpart__info\">\r\n                    <li>{{showProductName(l.productId)}}</li>\r\n                    <li>Calories: {{showProductCalories(l.productId, l.amount)}}</li>\r\n                    <li>{{showProductUnit(l.productId)}}: {{setAmount(l.productId,l.amount)}}</li>\r\n                    <li><button (click)=\"deleteMealProduct(l.id, 1, l.productId)\">delete</button></li>\r\n                </ul>\r\n            </li>\r\n            <li class=\"mealpart__header\">\r\n                <h3>Dinner</h3>\r\n                <div class=\"mealspart__button\">\r\n                    <button (click)=\"showProducts(2)\">add</button>\r\n                </div>\r\n            </li>\r\n            <li class=\"mealpart__main\" *ngFor=\"let d of dinner\">\r\n                <ul class=\"mealpart__info\">\r\n                    <li>{{showProductName(d.productId)}}</li>\r\n                    <li>Calories: {{showProductCalories(d.productId, d.amount)}}</li>\r\n                    <li>{{showProductUnit(d.productId)}}: {{setAmount(d.productId, d.amount)}}</li>\r\n                    <li><button (click)=\"deleteMealProduct(d.id, 2, d.productId)\">delete</button></li>\r\n                </ul>\r\n            </li>\r\n            <li class=\"mealpart__header\">\r\n                <h3>Snack</h3>\r\n                <div class=\"mealspart__button\">\r\n                    <button (click)=\"showProducts(3)\">add</button>\r\n                </div>\r\n            </li>\r\n            <li class=\"mealpart__main\" *ngFor=\"let s of snack\">\r\n                <ul class=\"mealpart__info\">\r\n                    <li>{{showProductName(s.productId)}}</li>\r\n                    <li>Calories: {{showProductCalories(s.productId, s.amount)}}</li>\r\n                    <li>{{showProductUnit(s.productId)}}: {{setAmount(s.productId,s.amount)}}</li>\r\n                    <li><button (click)=\"deleteMealProduct(s.id, 3, s.productId)\">delete</button></li>\r\n                </ul>\r\n            </li>\r\n        </ul>\r\n    </div>\r\n</div>"
        },
        {
            "name": "MenuComponent",
            "id": "component-MenuComponent-0189f413cb62d4214b9474091a8a75a9951e30b8c0e65cb401f89c5cf3fececadc324067cc04da4b846987b9ce3aaf5631dacbc1ef0224f77a20e5870ea865fb",
            "file": "src/app/pages/menu/menu.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-menu",
            "styleUrls": [
                "./menu.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./menu.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 12,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'app-menu',\r\n  templateUrl: './menu.component.html',\r\n  styleUrls: ['./menu.component.scss']\r\n})\r\nexport class MenuComponent implements OnInit {\r\n\r\n  constructor() { }\r\n\r\n  ngOnInit(): void {\r\n  }\r\n\r\n}\r\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".menu{\r\n    overflow: auto;\r\n    grid-area: menu;\r\n    display: grid;\r\n    border: #64D36F 1px solid;\r\n    height: 100%;\r\n}\r\n.menu__list{\r\n    margin: 9px 9px 0px 9px;\r\n    padding: 0;\r\n}\r\n.menu__link{\r\n    display: grid;\r\n    background-color: #D9D9D9;\r\n    border: #64D36F 1px solid;\r\n    margin: 0px 0px 5px 0px;\r\n    padding: 9px 14px;\r\n}\r\n\r\n\r\n\r\n\r\n",
                    "styleUrl": "./menu.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 8
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<div class=\"menu\">\r\n    <ul class=\"menu__list\">\r\n        <li class=\"menu__link\"><a routerLink=\"/meals\">Meals</a></li>\r\n        <li class=\"menu__link\"><a routerLink=\"/products\">Products</a></li>\r\n        <li class=\"menu__link\"><a routerLink=\"/goals\">Goals</a></li>\r\n        <li class=\"menu__link\"><a routerLink=\"/settings\">Settings</a></li>\r\n        <li class=\"menu__link\"><a routerLink=\"/help\">Help</a></li>        \r\n    </ul>\r\n</div>"
        },
        {
            "name": "PageComponent",
            "id": "component-PageComponent-7126d8c2607c946741c651482413b43feb72b2d63cac9d3ac173fde206a5e635eb4cdbf7ca7ac9327c7d4d05cf7ef619144c34c11609ad677081d0ee4e855064",
            "file": "src/stories/page.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "storybook-page",
            "styleUrls": [
                "./page.css"
            ],
            "styles": [],
            "template": "<article>    <storybook-header\n      [user]=\"user\"\n      (onLogout)=\"doLogout()\"\n      (onLogin)=\"doLogin()\"\n      (onCreateAccount)=\"doCreateAccount()\"\n    ></storybook-header>\n    <section>\n      <h2>Pages in Storybook</h2>\n      <p>\n        We recommend building UIs with a\n        <a href=\"https://componentdriven.org\" target=\"_blank\" rel=\"noopener noreferrer\">\n          <strong>component-driven</strong>\n        </a>\n        process starting with atomic components and ending with pages.\n      </p>\n      <p>\n        Render pages with mock data. This makes it easy to build and review page states without\n        needing to navigate to them in your app. Here are some handy patterns for managing page data\n        in Storybook:\n      </p>\n      <ul>\n        <li>\n          Use a higher-level connected component. Storybook helps you compose such data from the\n          \"args\" of child component stories\n        </li>\n        <li>\n          Assemble data in the page component from your services. You can mock these services out\n          using Storybook.\n        </li>\n      </ul>\n      <p>\n        Get a guided tutorial on component-driven development at\n        <a href=\"https://storybook.js.org/tutorials/\" target=\"_blank\" rel=\"noopener noreferrer\">\n          Storybook tutorials\n        </a>\n        . Read more in the\n        <a href=\"https://storybook.js.org/docs\" target=\"_blank\" rel=\"noopener noreferrer\"> docs </a>\n        .\n      </p>\n      <div class=\"tip-wrapper\">\n        <span class=\"tip\">Tip</span> Adjust the width of the canvas with the\n        <svg width=\"10\" height=\"10\" viewBox=\"0 0 12 12\" xmlns=\"http://www.w3.org/2000/svg\">\n          <g fill=\"none\" fillRule=\"evenodd\">\n            <path\n              d=\"M1.5 5.2h4.8c.3 0 .5.2.5.4v5.1c-.1.2-.3.3-.4.3H1.4a.5.5 0 01-.5-.4V5.7c0-.3.2-.5.5-.5zm0-2.1h6.9c.3 0 .5.2.5.4v7a.5.5 0 01-1 0V4H1.5a.5.5 0 010-1zm0-2.1h9c.3 0 .5.2.5.4v9.1a.5.5 0 01-1 0V2H1.5a.5.5 0 010-1zm4.3 5.2H2V10h3.8V6.2z\"\n              id=\"a\"\n              fill=\"#999\"\n            />\n          </g>\n        </svg>\n        Viewports addon in the toolbar\n      </div>\n    </section>\n  </article>",
            "templateUrl": [],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "user",
                    "defaultValue": "null",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "User | null",
                    "optional": false,
                    "description": "",
                    "line": 64
                }
            ],
            "methodsClass": [
                {
                    "name": "doCreateAccount",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 74,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "doLogin",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 70,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "doLogout",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 66,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component } from '@angular/core';\nimport { User } from './User';\n\n@Component({\n  selector: 'storybook-page',\n  template: `<article>\n    <storybook-header\n      [user]=\"user\"\n      (onLogout)=\"doLogout()\"\n      (onLogin)=\"doLogin()\"\n      (onCreateAccount)=\"doCreateAccount()\"\n    ></storybook-header>\n    <section>\n      <h2>Pages in Storybook</h2>\n      <p>\n        We recommend building UIs with a\n        <a href=\"https://componentdriven.org\" target=\"_blank\" rel=\"noopener noreferrer\">\n          <strong>component-driven</strong>\n        </a>\n        process starting with atomic components and ending with pages.\n      </p>\n      <p>\n        Render pages with mock data. This makes it easy to build and review page states without\n        needing to navigate to them in your app. Here are some handy patterns for managing page data\n        in Storybook:\n      </p>\n      <ul>\n        <li>\n          Use a higher-level connected component. Storybook helps you compose such data from the\n          \"args\" of child component stories\n        </li>\n        <li>\n          Assemble data in the page component from your services. You can mock these services out\n          using Storybook.\n        </li>\n      </ul>\n      <p>\n        Get a guided tutorial on component-driven development at\n        <a href=\"https://storybook.js.org/tutorials/\" target=\"_blank\" rel=\"noopener noreferrer\">\n          Storybook tutorials\n        </a>\n        . Read more in the\n        <a href=\"https://storybook.js.org/docs\" target=\"_blank\" rel=\"noopener noreferrer\"> docs </a>\n        .\n      </p>\n      <div class=\"tip-wrapper\">\n        <span class=\"tip\">Tip</span> Adjust the width of the canvas with the\n        <svg width=\"10\" height=\"10\" viewBox=\"0 0 12 12\" xmlns=\"http://www.w3.org/2000/svg\">\n          <g fill=\"none\" fillRule=\"evenodd\">\n            <path\n              d=\"M1.5 5.2h4.8c.3 0 .5.2.5.4v5.1c-.1.2-.3.3-.4.3H1.4a.5.5 0 01-.5-.4V5.7c0-.3.2-.5.5-.5zm0-2.1h6.9c.3 0 .5.2.5.4v7a.5.5 0 01-1 0V4H1.5a.5.5 0 010-1zm0-2.1h9c.3 0 .5.2.5.4v9.1a.5.5 0 01-1 0V2H1.5a.5.5 0 010-1zm4.3 5.2H2V10h3.8V6.2z\"\n              id=\"a\"\n              fill=\"#999\"\n            />\n          </g>\n        </svg>\n        Viewports addon in the toolbar\n      </div>\n    </section>\n  </article>`,\n  styleUrls: ['./page.css'],\n})\nexport default class PageComponent {\n  user: User | null = null;\n\n  doLogout() {\n    this.user = null;\n  }\n\n  doLogin() {\n    this.user = { name: 'Jane Doe' };\n  }\n\n  doCreateAccount() {\n    this.user = { name: 'Jane Doe' };\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "section {\n  font-family: 'Nunito Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\n  font-size: 14px;\n  line-height: 24px;\n  padding: 48px 20px;\n  margin: 0 auto;\n  max-width: 600px;\n  color: #333;\n}\n\nsection h2 {\n  font-weight: 900;\n  font-size: 32px;\n  line-height: 1;\n  margin: 0 0 4px;\n  display: inline-block;\n  vertical-align: top;\n}\n\nsection p {\n  margin: 1em 0;\n}\n\nsection a {\n  text-decoration: none;\n  color: #1ea7fd;\n}\n\nsection ul {\n  padding-left: 30px;\n  margin: 1em 0;\n}\n\nsection li {\n  margin-bottom: 8px;\n}\n\nsection .tip {\n  display: inline-block;\n  border-radius: 1em;\n  font-size: 11px;\n  line-height: 12px;\n  font-weight: 700;\n  background: #e7fdd8;\n  color: #66bf3c;\n  padding: 4px 12px;\n  margin-right: 10px;\n  vertical-align: top;\n}\n\nsection .tip-wrapper {\n  font-size: 13px;\n  line-height: 20px;\n  margin-top: 40px;\n  margin-bottom: 40px;\n}\n\nsection .tip-wrapper svg {\n  display: inline-block;\n  height: 12px;\n  width: 12px;\n  margin-right: 4px;\n  vertical-align: top;\n  margin-top: 3px;\n}\n\nsection .tip-wrapper svg path {\n  fill: #1ea7fd;\n}\n",
                    "styleUrl": "./page.css"
                }
            ],
            "stylesData": ""
        },
        {
            "name": "ProductsPageComponent",
            "id": "component-ProductsPageComponent-24ded498b73a4d5cb2317d6fb5afc73e2260805f2ee7b9ac8184f02eb5357bb4a4d2d4bede62f1688191d7475304f3c8c9cbc3e66c5dc6f5d3e36d2eb2deb422",
            "file": "src/app/pages/body/products-page/products-page.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-products-page",
            "styleUrls": [
                "./products-page.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./products-page.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 12,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'app-products-page',\r\n  templateUrl: './products-page.component.html',\r\n  styleUrls: ['./products-page.component.scss']\r\n})\r\nexport class ProductsPageComponent implements OnInit {\r\n\r\n  constructor() { }\r\n\r\n  ngOnInit(): void {\r\n  }\r\n\r\n}\r\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./products-page.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 8
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<h1>Products Page</h1>"
        },
        {
            "name": "ProductsPartComponent",
            "id": "component-ProductsPartComponent-58e29bc3edbdf412c71836192492bbf3c685c48082703f57a10933ffa52806afdb46aeccfcb774b3ed6e8f60d83a3cdd09f9f814dea269b618234376d01d2c50",
            "file": "src/app/pages/body/meals-page/products-part/products-part.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-products-part",
            "styleUrls": [
                "./products-part.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./products-part.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "amount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "optional": false,
                    "description": "",
                    "line": 16
                },
                {
                    "name": "componentRef",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ComponentRef<AmountDialogComponent>",
                    "optional": true,
                    "description": "",
                    "line": 23,
                    "modifierKind": [
                        121
                    ]
                },
                {
                    "name": "destroy$",
                    "defaultValue": "new Subject()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "optional": false,
                    "description": "",
                    "line": 17,
                    "modifierKind": [
                        121
                    ]
                },
                {
                    "name": "isFocused",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "optional": false,
                    "description": "",
                    "line": 20
                },
                {
                    "name": "mealsController",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MealsController",
                    "optional": false,
                    "description": "",
                    "line": 27,
                    "modifierKind": [
                        121,
                        144
                    ]
                },
                {
                    "name": "products",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<Product>",
                    "optional": false,
                    "description": "",
                    "line": 24
                },
                {
                    "name": "productService",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ProductsService",
                    "optional": false,
                    "description": "",
                    "line": 26,
                    "modifierKind": [
                        121,
                        144
                    ]
                },
                {
                    "name": "searchInput",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "optional": false,
                    "description": "",
                    "line": 19
                },
                {
                    "name": "targetTypeOfMeal",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TypeOfMeal",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "modifierKind": [
                        121
                    ]
                },
                {
                    "name": "viewRef",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ViewContainerRef",
                    "optional": true,
                    "description": "",
                    "line": 22,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'amount', {read: ViewContainerRef}"
                        }
                    ],
                    "modifierKind": [
                        121
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnDestroy",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 40,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 34,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "searchProducts",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 47,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "setAmount",
                    "args": [
                        {
                            "name": "unit",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 88,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "unit",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setFocus",
                    "args": [
                        {
                            "name": "type",
                            "type": "TypeOfMeal",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 67,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        121
                    ],
                    "jsdoctags": [
                        {
                            "name": "type",
                            "type": "TypeOfMeal",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "showAmountDialog",
                    "args": [
                        {
                            "name": "product",
                            "type": "Product",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 53,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "product",
                            "type": "Product",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "showProductUnit",
                    "args": [
                        {
                            "name": "unit",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 72,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "unit",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, ComponentRef, OnDestroy, OnInit, ViewChild } from '@angular/core';\r\nimport { ProductsService } from 'src/app/services/products.service';\r\nimport { Product } from 'src/app/models/product';\r\nimport { AmountDialogComponent } from '../amount-dialog/amount-dialog.component';\r\nimport { ViewContainerRef } from '@angular/core';\r\nimport { MealsController } from 'src/app/services/meals.controller';\r\nimport { TypeOfMeal } from 'src/app/models/meal';\r\nimport { Subject, Subscription, takeUntil } from 'rxjs';\r\n\r\n@Component({\r\n  selector: 'app-products-part',\r\n  templateUrl: './products-part.component.html',\r\n  styleUrls: ['./products-part.component.scss']\r\n})\r\nexport class ProductsPartComponent implements OnInit, OnDestroy {\r\n  amount!: number;\r\n  private destroy$ = new Subject();\r\n  private targetTypeOfMeal!: TypeOfMeal;\r\n  searchInput!: string;\r\n  isFocused: boolean = false;\r\n  @ViewChild('amount', { read: ViewContainerRef })\r\n  private viewRef?: ViewContainerRef;\r\n  private componentRef?: ComponentRef<AmountDialogComponent>;\r\n  products: Array<Product> = [];\r\n\r\n  private readonly productService: ProductsService;\r\n  private readonly mealsController: MealsController;\r\n \r\n  constructor(productService: ProductsService, mealsController: MealsController) {\r\n    this.productService = productService;\r\n    this.mealsController = mealsController;\r\n  }\r\n\r\n  ngOnInit(): void {\r\n    this.mealsController.isFocused$\r\n      .pipe(takeUntil(this.destroy$))\r\n      .subscribe(type => this.setFocus(type));\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this.destroy$.next(true);\r\n    this.destroy$.complete();\r\n    this.componentRef?.destroy();\r\n    this.viewRef?.detach();\r\n  }\r\n\r\n  public searchProducts() {\r\n    this.productService.searchProducts(this.searchInput).subscribe((response)=> {\r\n      this.products = response;\r\n    });\r\n  }\r\n\r\n  public showAmountDialog(product: Product) {\r\n    this.viewRef?.clear();\r\n    this.componentRef = this.viewRef?.createComponent(AmountDialogComponent);\r\n    this.componentRef?.instance.close.subscribe(() => {\r\n      this.viewRef?.clear();\r\n    });\r\n\r\n    this.componentRef?.instance.accept.subscribe(() => {\r\n      this.viewRef?.clear();\r\n      this.amount = this.componentRef?.instance.amount!;\r\n      this.mealsController.addProduct(product, this.targetTypeOfMeal, this.amount);\r\n    })\r\n  }\r\n\r\n  private setFocus(type: TypeOfMeal) {\r\n    this.targetTypeOfMeal = type;\r\n    this.isFocused = true;\r\n  }\r\n  //       \r\n  showProductUnit(unit: number): string{\r\n    switch (unit) {\r\n      case 0:\r\n        return \"Milliliters\"\r\n        break;\r\n      case 1:\r\n        return \"Gram\"\r\n        break;\r\n      case 2:\r\n        return \"Pieces\"\r\n        break;\r\n      default:\r\n        return \"\";\r\n        break;\r\n    }\r\n  }\r\n  setAmount(unit: number): number{\r\n    switch (unit) {\r\n      case 0:\r\n        return 100\r\n        break;\r\n      case 1:\r\n        return 100\r\n        break;\r\n      case 2:\r\n        return 1\r\n        break;\r\n      default:\r\n        return 0;\r\n        break;\r\n    }\r\n  }\r\n}\r\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".productpart {\r\n    grid-area: products-part;\r\n    display: grid;\r\n    height: 100%;\r\n    margin: 0px;\r\n    padding: 0px;\r\n    grid-template-rows: 1fr 13fr;\r\n}\r\n\r\n.productpart__header {\r\n    display: grid;\r\n    grid-template: 1fr / 1fr 1fr;\r\n    align-items: center;\r\n    justify-items: start;\r\n}\r\n\r\n.productpart__search {\r\n    font-size: 20px;\r\n    margin-left: 20px;\r\n}\r\n\r\n\r\ninput {\r\n    padding: 10px 9px;\r\n    width: 70%;\r\n    outline: none;\r\n    border: 1px solid #64D36F;\r\n    background-color: #D9D9D9;\r\n}\r\n\r\n.productpart__list {\r\n    margin: 53px 20px 0px 20px;\r\n    padding: 0px;\r\n   \r\n}\r\n\r\n.inner {}\r\n\r\n.productpart__product {\r\n    display: grid;\r\n        grid-template-columns: 1fr 1fr 1fr 1fr;\r\n        padding: 7px;\r\n        padding-left: 20px;\r\n        margin-bottom: 10px;\r\n        background-color: #D9D9D9;\r\n        border: 1px solid #64D36F;\r\n}",
                    "styleUrl": "./products-part.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "productService",
                        "type": "ProductsService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "mealsController",
                        "type": "MealsController",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 27,
                "jsdoctags": [
                    {
                        "name": "productService",
                        "type": "ProductsService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "mealsController",
                        "type": "MealsController",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "implements": [
                "OnInit",
                "OnDestroy"
            ],
            "templateData": "<!-- <ng-template appRef></ng-template> -->\r\n<div class=\"productpart\" *ngIf=\"isFocused\">\r\n    <div class=\"productpart__header\">\r\n        <input [(ngModel)]=\"searchInput\"  (ngModelChange)=\"searchProducts()\"  class=\"productpart__search\" type=\"text\">\r\n    </div>\r\n    <div class=\"productpart__products\">\r\n        <ul class=\"productpart__list\">\r\n            <li *ngFor=\"let product of products\">\r\n                <ul class=\"productpart__product\">\r\n                    <li>{{product.name}}</li>\r\n                    <li>Calories: {{product.calories}}</li>\r\n                    <li>{{showProductUnit(product.unit)}}: {{setAmount(product.unit)}} </li>\r\n                    <li><button (click)=\"showAmountDialog(product)\">add</button></li>\r\n                    <ng-template #amount></ng-template>\r\n                </ul>\r\n            </li>\r\n        </ul>\r\n    </div>\r\n</div>"
        },
        {
            "name": "PromptComponent",
            "id": "component-PromptComponent-15b8b7960afe10531c6e9c914f4d55b817c1d0a98e9abaf1b39a86ee1d115d0577dc0c27ef31fc1806a28a8a514f19b13ad574cf65b7f213c4f40f2dd1b6a033",
            "file": "src/app/pages/prompt/prompt.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-prompt",
            "styleUrls": [
                "./prompt.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./prompt.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 12,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'app-prompt',\r\n  templateUrl: './prompt.component.html',\r\n  styleUrls: ['./prompt.component.scss']\r\n})\r\nexport class PromptComponent implements OnInit {\r\n\r\n  constructor() { }\r\n\r\n  ngOnInit(): void {\r\n  }\r\n\r\n}\r\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "// a:active, /* /  */\r\n// a:hover,  /*   */\r\n// a {\r\n//   text-decoration: none;\r\n//   color: #000000;\r\n//   font-size: 20px;\r\n// }\r\n\r\n// li{list-style: none;}\r\n\r\n// .prompt-bar{\r\n//     // width: 13%;\r\n//     // height: 90%;\r\n//     // border-left: solid 1px #64D36F;\r\n//     // position: fixed;\r\n//     // top: 0px;\r\n//     // right: 0px;\r\n\r\n// }\r\n// .prompt-bar ul{\r\n//     padding-top: 60px;\r\n//     padding-left: 6%;\r\n\r\n//   }\r\n//   .prompt-bar li{\r\n//   border: #64D36F solid 1px;\r\n//   width: 92.8%;\r\n//   height: 240px;\r\n//   background-color: #D9D9D9;\r\n//   align-items: center;\r\n//   margin-bottom: 10px;\r\n//   }\r\n//   .prompt-bar img{\r\n//     margin-left: 9px;\r\n//   }\r\n//   li p{\r\n//     margin-top: -26px;\r\n//     text-align: center;\r\n//     font-size: 1vh;\r\n//     line-height: 0.9em;\r\n//   }\r\np{margin: 0;}\r\n.prompt {\r\n    grid-area: prompt;\r\n    display: grid;\r\n    height: 100%;\r\n    border: 1px solid #64D36F;\r\n    // padding: 0px;\r\n    // margin: 0px;\r\n}\r\n\r\n.prompt__list {\r\n    display: grid;\r\n    grid-auto-flow: row;\r\n    padding: 15px 15px 0px 15px;\r\n    margin: 0px;\r\n    grid-template: 1fr 1fr 1fr/1fr;\r\n}\r\n\r\n.prompt__image {\r\nposition: relative;\r\npadding: 0px 0px 80% 0px;\r\nmargin: 0px 0px 0px 0px;\r\n}\r\n\r\n.prompt__info img {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n    top:0;\r\n    left: 0;\r\n    object-fit: cover;\r\n}\r\n\r\n.prompt__text{\r\n    text-align: center;\r\n    font-size: 14px;\r\n}",
                    "styleUrl": "./prompt.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 8
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<div class=\"prompt\">\r\n    <ul class=\"prompt__list\">\r\n        <li class=\"prompt__info\">\r\n            <div class=\"prompt__image\">\r\n                <img width=\"80\" height=\"80\" src=\"https://itproger.com/img/courses/1476977584.jpg\" alt=\"picture\">\r\n            </div>\r\n            <div class=\"prompt__text\">\r\n                <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Rerum harum dolor nemo deleniti magnam\r\n                    iusto mollitia a? Debitis, inventore!</p>\r\n            </div>\r\n        </li>\r\n        <li class=\"prompt__info\">\r\n            <div class=\"prompt__image\">\r\n                <img width=\"80\" height=\"80\" src=\"https://itproger.com/img/courses/1476977584.jpg\" alt=\"picture\">\r\n            </div>\r\n            <div class=\"prompt__text\">\r\n                <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Rerum harum dolor nemo deleniti magnam\r\n                    iusto mollitia a? Debitis, inventore!</p>\r\n            </div>\r\n        </li>\r\n        <li class=\"prompt__info\">\r\n            <div class=\"prompt__image\">\r\n                <img width=\"80\" height=\"80\" src=\"https://itproger.com/img/courses/1476977584.jpg\" alt=\"picture\">\r\n            </div>\r\n            <div class=\"prompt__text\">\r\n                <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Rerum harum dolor nemo deleniti magnam\r\n                    iusto mollitia a? Debitis, inventore!</p>\r\n            </div>\r\n        </li>\r\n\r\n    </ul>\r\n</div>"
        },
        {
            "name": "RegisterPageComponent",
            "id": "component-RegisterPageComponent-f32110e12bda196dd28ec70dfadc26046708a8ec8d0c7b9c1c20538c48fde459efcdf8340bbb84c0d5f932f22975572d29363f3b4fa118ee4e6339c2a71eff74",
            "file": "src/app/pages/body/register-page/register-page.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-register-page",
            "styleUrls": [
                "./register-page.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./register-page.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 12,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'app-register-page',\r\n  templateUrl: './register-page.component.html',\r\n  styleUrls: ['./register-page.component.scss']\r\n})\r\nexport class RegisterPageComponent implements OnInit {\r\n\r\n  constructor() { }\r\n\r\n  ngOnInit(): void {\r\n  }\r\n\r\n}\r\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./register-page.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 8
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<p>register works!</p>\r\n"
        },
        {
            "name": "SettingsPageComponent",
            "id": "component-SettingsPageComponent-095a85359cbcb64957c73e2883b27be6bfa32275cc22be64d1c817d8876130b8a467e2acd33837a0cfa570143094017475101795de457cddb2d5562d52c47378",
            "file": "src/app/pages/body/settings-page/settings-page.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-settings-page",
            "styleUrls": [
                "./settings-page.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./settings-page.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 12,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'app-settings-page',\r\n  templateUrl: './settings-page.component.html',\r\n  styleUrls: ['./settings-page.component.scss']\r\n})\r\nexport class SettingsPageComponent implements OnInit {\r\n\r\n  constructor() { }\r\n\r\n  ngOnInit(): void {\r\n  }\r\n\r\n}\r\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./settings-page.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 8
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<h1>Settings Page</h1>"
        },
        {
            "name": "WcButtonComponent",
            "id": "component-WcButtonComponent-3d96793cddd94b44aa4510614f32589f33e96462f64efbe8b18b4910cc5ab5df0c0339e87c06188eb2fadd26a1d8550bcf9c096dfd4c291415a7d283c35b5627",
            "file": "src/app/components/wc-button/wc-button.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "wc-button",
            "styleUrls": [
                "./wc-button.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./wc-button.component.html"
            ],
            "viewProviders": [],
            "inputsClass": [
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 14,
                    "type": "string",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "buttonClick",
                    "defaultValue": "new EventEmitter<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 18,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 20,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onClick",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 23,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, EventEmitter, Input, OnInit, Output} from '@angular/core';\n\n@Component({\n  selector: 'wc-button',\n  templateUrl: './wc-button.component.html',\n  styleUrls: ['./wc-button.component.scss']\n})\nexport class WcButtonComponent implements OnInit {\n\n  constructor() { }\n\n  //Inputs\n  @Input()\n  label?: string;\n\n  //Output\n  @Output()\n  buttonClick = new EventEmitter<void>();\n\n  ngOnInit(): void {\n  }\n\n  onClick(){\n    this.buttonClick.emit();\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./wc-button.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 8
            },
            "implements": [
                "OnInit"
            ],
            "templateData": "<button\n  mat-button\n  (click)=\"onClick()\"\n>\n  {{label}}\n</button>\n"
        }
    ],
    "modules": [
        {
            "name": "AppModule",
            "id": "module-AppModule-866df1503222e35c8d6565d44451b28c55fe5539d4383a20c51f135abbfa73b26cc4e8abf204bc9102607c3764df9296a621a9ea0f896647111bd49c5dccafa2",
            "description": "",
            "deprecationMessage": "",
            "deprecated": false,
            "file": "src/app/app.module.ts",
            "methods": [],
            "sourceCode": "import { NgModule } from '@angular/core';\r\nimport { BrowserModule } from '@angular/platform-browser';\r\nimport { HttpClientModule} from '@angular/common/http'\r\nimport { AppRoutingModule } from './app-routing.module';\r\nimport { AppComponent } from './app.component';\r\nimport { HeaderComponent } from './pages/header/header.component';\r\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\r\nimport { MenuComponent } from './pages/menu/menu.component';\r\nimport { PromptComponent } from './pages/prompt/prompt.component';\r\nimport { FooterComponent } from './pages/footer/footer.component';\r\nimport { ProductsPageComponent } from './pages/body/products-page/products-page.component';\r\nimport { GoalsPageComponent } from './pages/body/goals-page/goals-page.component';\r\nimport { SettingsPageComponent } from './pages/body/settings-page/settings-page.component';\r\nimport { HelpPageComponent } from './pages/body/help-page/help-page.component';\r\nimport { MealsPageComponent } from './pages/body/meals-page/meals-page.component';\r\nimport { MealsPartComponent } from './pages/body/meals-page/meals-part/meals-part.component';\r\nimport { ProductsPartComponent } from './pages/body/meals-page/products-part/products-part.component';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { AmountDialogComponent } from './pages/body/meals-page/amount-dialog/amount-dialog.component';\r\nimport { ApiClient, API_BASE_URL } from './clients/api.client';\r\nimport { environment } from 'src/environments/environment';\r\nimport { LoginPageComponent } from './pages/body/login-page/login-page.component';\r\nimport { RegisterPageComponent } from './pages/body/register-page/register-page.component';\r\nimport { WcButtonComponent } from './components/wc-button/wc-button.component';\r\n\r\n@NgModule({\r\n  declarations: [\r\n    AppComponent,\r\n    HeaderComponent,\r\n    MenuComponent,\r\n    PromptComponent,\r\n    FooterComponent,\r\n    ProductsPageComponent,\r\n    MealsPageComponent,\r\n    GoalsPageComponent,\r\n    SettingsPageComponent,\r\n    HelpPageComponent,\r\n    MealsPartComponent,\r\n    ProductsPartComponent,\r\n    AmountDialogComponent,\r\n    LoginPageComponent,\r\n    RegisterPageComponent,\r\n    WcButtonComponent\r\n  ],\r\n  entryComponents: [\r\n    AmountDialogComponent,\r\n  ],\r\n  imports: [\r\n    BrowserModule,\r\n    AppRoutingModule,\r\n    BrowserAnimationsModule,\r\n    FormsModule,\r\n    HttpClientModule\r\n  ],\r\n  providers: [\r\n    ApiClient,\r\n    { provide: API_BASE_URL, useValue: environment.apiUrl }\r\n  ],\r\n  bootstrap: [AppComponent]\r\n})\r\nexport class AppModule { }\r\n",
            "children": [
                {
                    "type": "providers",
                    "elements": [
                        {
                            "name": "ApiClient"
                        }
                    ]
                },
                {
                    "type": "declarations",
                    "elements": [
                        {
                            "name": "AmountDialogComponent"
                        },
                        {
                            "name": "AppComponent"
                        },
                        {
                            "name": "FooterComponent"
                        },
                        {
                            "name": "GoalsPageComponent"
                        },
                        {
                            "name": "HelpPageComponent"
                        },
                        {
                            "name": "LoginPageComponent"
                        },
                        {
                            "name": "MealsPageComponent"
                        },
                        {
                            "name": "MealsPartComponent"
                        },
                        {
                            "name": "MenuComponent"
                        },
                        {
                            "name": "ProductsPageComponent"
                        },
                        {
                            "name": "ProductsPartComponent"
                        },
                        {
                            "name": "PromptComponent"
                        },
                        {
                            "name": "RegisterPageComponent"
                        },
                        {
                            "name": "SettingsPageComponent"
                        },
                        {
                            "name": "WcButtonComponent"
                        }
                    ]
                },
                {
                    "type": "imports",
                    "elements": [
                        {
                            "name": "AppRoutingModule"
                        }
                    ]
                },
                {
                    "type": "exports",
                    "elements": []
                },
                {
                    "type": "bootstrap",
                    "elements": [
                        {
                            "name": "AppComponent"
                        }
                    ]
                },
                {
                    "type": "classes",
                    "elements": []
                }
            ]
        },
        {
            "name": "AppRoutingModule",
            "id": "module-AppRoutingModule-b30dc6e182f0e092d52b0fd80f156710c30a926bf037ad415209696d6c6b0d3340db961df70f70b4478de4173376e9e50ba79e89e75c9263946fc6ad0d26d2b7",
            "description": "",
            "deprecationMessage": "",
            "deprecated": false,
            "file": "src/app/app-routing.module.ts",
            "methods": [],
            "sourceCode": "import { NgModule } from '@angular/core';\r\nimport { RouterModule, Routes } from '@angular/router';\r\nimport { ProductsPageComponent } from './pages/body/products-page/products-page.component';\r\nimport { MealsPageComponent } from './pages/body/meals-page/meals-page.component';\r\nimport { GoalsPageComponent } from './pages/body/goals-page/goals-page.component';\r\nimport { SettingsPageComponent } from './pages/body/settings-page/settings-page.component';\r\nimport { HelpPageComponent } from './pages/body/help-page/help-page.component';\r\nimport {LoginPageComponent} from \"./pages/body/login-page/login-page.component\";\r\nimport {RegisterPageComponent} from \"./pages/body/register-page/register-page.component\";\r\n\r\nconst routes: Routes = [\r\n  {path: '', redirectTo: '/meals', pathMatch: 'full' },\r\n  {path: 'products', component: ProductsPageComponent},\r\n  {path: 'meals', component: MealsPageComponent},\r\n  {path: 'goals', component: GoalsPageComponent},\r\n  {path: 'settings', component: SettingsPageComponent},\r\n  {path: 'help', component: HelpPageComponent},\r\n  {path: 'login', component:LoginPageComponent},\r\n  {path: 'register', component: RegisterPageComponent}\r\n];\r\n\r\n@NgModule({\r\n  imports: [RouterModule.forRoot(routes)],\r\n  exports: [RouterModule]\r\n})\r\nexport class AppRoutingModule { }\r\n",
            "children": [
                {
                    "type": "providers",
                    "elements": []
                },
                {
                    "type": "declarations",
                    "elements": []
                },
                {
                    "type": "imports",
                    "elements": []
                },
                {
                    "type": "exports",
                    "elements": []
                },
                {
                    "type": "bootstrap",
                    "elements": []
                },
                {
                    "type": "classes",
                    "elements": []
                }
            ]
        },
        {
            "name": "WcButtonModule",
            "id": "module-WcButtonModule-f967de171f93586c82d571e140f89d53b7300c993e8a4a073221bfaed8a5a5f3d5d1e0b9273ef6a40088384f9bc9f1c240ed8a34fbf9160f006d664059af6f0b",
            "description": "",
            "deprecationMessage": "",
            "deprecated": false,
            "file": "src/app/components/wc-button/wc-button.module.ts",
            "methods": [],
            "sourceCode": "import {NgModule} from \"@angular/core\";\r\nimport {WcButtonComponent} from \"./wc-button.component\";\r\nimport {MatButtonModule} from '@angular/material/button';\r\n\r\n@NgModule({\r\n  declarations:[WcButtonComponent],\r\n  imports:[MatButtonModule],\r\n  exports:[WcButtonComponent]\r\n})\r\n\r\nexport class WcButtonModule {}\r\n",
            "children": [
                {
                    "type": "providers",
                    "elements": []
                },
                {
                    "type": "declarations",
                    "elements": [
                        {
                            "name": "WcButtonComponent"
                        }
                    ]
                },
                {
                    "type": "imports",
                    "elements": []
                },
                {
                    "type": "exports",
                    "elements": [
                        {
                            "name": "WcButtonComponent"
                        }
                    ]
                },
                {
                    "type": "bootstrap",
                    "elements": []
                },
                {
                    "type": "classes",
                    "elements": []
                }
            ]
        }
    ],
    "miscellaneous": {
        "variables": [
            {
                "name": "API_BASE_URL",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/clients/api.client.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "new InjectionToken<string>('API_BASE_URL')"
            },
            {
                "name": "context",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/test.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "require.context('./', true, /\\.spec\\.ts$/)"
            },
            {
                "name": "environment",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/environments/environment.prod.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "object",
                "defaultValue": "{\r\n  production: true,\r\n}"
            },
            {
                "name": "environment",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/environments/environment.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "object",
                "defaultValue": "{\r\n  production: true,\r\n  apiUrl: \"https://localhost:49714\"\r\n}"
            },
            {
                "name": "Large",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Button.stories.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "LoggedIn",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Header.stories.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "LoggedIn",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Page.stories.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "LoggedOut",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Header.stories.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "LoggedOut",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Page.stories.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "Primary",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Button.stories.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "Primary",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/components/wc-button/wc-button.component.stories.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "require",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/test.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "literal type"
            },
            {
                "name": "Secondary",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Button.stories.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "Small",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Button.stories.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "",
                "defaultValue": "Template.bind({})"
            },
            {
                "name": "Template",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Button.stories.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Story<Button>",
                "defaultValue": "(args: Button) => ({\n  props: args,\n})"
            },
            {
                "name": "Template",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Header.stories.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Story<Header>",
                "defaultValue": "(args: Header) => ({\n  props: args,\n})"
            },
            {
                "name": "Template",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/stories/Page.stories.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Story<Page>",
                "defaultValue": "(args: Page) => ({\n  props: args,\n})"
            },
            {
                "name": "Template",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/components/wc-button/wc-button.component.stories.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Story<WcButtonComponent>",
                "defaultValue": "args => ({\r\n  props: args,\r\n  template: `\r\n    <div style=\"display: flex;\">\r\n        <wc-button\r\n            [label]=\"label\"\r\n            (buttonClick)=\"buttonClick()\">\r\n        </wc-button>\r\n    </div>`\r\n})"
            }
        ],
        "functions": [
            {
                "name": "blobToText",
                "file": "src/app/clients/api.client.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "blob",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "Observable<string>",
                "jsdoctags": [
                    {
                        "name": "blob",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "throwException",
                "file": "src/app/clients/api.client.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "message",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "status",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "response",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "headers",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "result",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    }
                ],
                "returnType": "Observable<any>",
                "jsdoctags": [
                    {
                        "name": "message",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "status",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "response",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "headers",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "result",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            }
        ],
        "typealiases": [],
        "enumerations": [
            {
                "name": "LoginError",
                "childs": [
                    {
                        "name": "_0",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": 0
                    },
                    {
                        "name": "_1",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": 1
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/clients/api.client.ts"
            },
            {
                "name": "RegisterError",
                "childs": [
                    {
                        "name": "_0",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": 0
                    },
                    {
                        "name": "_1",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": 1
                    },
                    {
                        "name": "_2",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": 2
                    },
                    {
                        "name": "_3",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": 3
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/clients/api.client.ts"
            },
            {
                "name": "TypeofFood",
                "childs": [
                    {
                        "name": "Meat",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "Drink",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "Cereal",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "Vegetable",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "Fruit",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "Confection",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "Bake",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "Garnish",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "Berrie",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/models/product.ts"
            },
            {
                "name": "TypeOfMeal",
                "childs": [
                    {
                        "name": "breakfast",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "lunch",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "dinner",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "snack",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/models/meal.ts"
            },
            {
                "name": "unitType",
                "childs": [
                    {
                        "name": "Milliliters",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "Gram",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "Pieces",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/models/product.ts"
            }
        ],
        "groupedVariables": {
            "src/app/clients/api.client.ts": [
                {
                    "name": "API_BASE_URL",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/clients/api.client.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "new InjectionToken<string>('API_BASE_URL')"
                }
            ],
            "src/test.ts": [
                {
                    "name": "context",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/test.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "require.context('./', true, /\\.spec\\.ts$/)"
                },
                {
                    "name": "require",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/test.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type"
                }
            ],
            "src/environments/environment.prod.ts": [
                {
                    "name": "environment",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/environments/environment.prod.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "defaultValue": "{\r\n  production: true,\r\n}"
                }
            ],
            "src/environments/environment.ts": [
                {
                    "name": "environment",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/environments/environment.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "defaultValue": "{\r\n  production: true,\r\n  apiUrl: \"https://localhost:49714\"\r\n}"
                }
            ],
            "src/stories/Button.stories.ts": [
                {
                    "name": "Large",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Button.stories.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "Primary",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Button.stories.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "Secondary",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Button.stories.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "Small",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Button.stories.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "Template",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Button.stories.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Story<Button>",
                    "defaultValue": "(args: Button) => ({\n  props: args,\n})"
                }
            ],
            "src/stories/Header.stories.ts": [
                {
                    "name": "LoggedIn",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Header.stories.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "LoggedOut",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Header.stories.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "Template",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Header.stories.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Story<Header>",
                    "defaultValue": "(args: Header) => ({\n  props: args,\n})"
                }
            ],
            "src/stories/Page.stories.ts": [
                {
                    "name": "LoggedIn",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Page.stories.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "LoggedOut",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Page.stories.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "Template",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/stories/Page.stories.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Story<Page>",
                    "defaultValue": "(args: Page) => ({\n  props: args,\n})"
                }
            ],
            "src/app/components/wc-button/wc-button.component.stories.ts": [
                {
                    "name": "Primary",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/components/wc-button/wc-button.component.stories.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "defaultValue": "Template.bind({})"
                },
                {
                    "name": "Template",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/components/wc-button/wc-button.component.stories.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Story<WcButtonComponent>",
                    "defaultValue": "args => ({\r\n  props: args,\r\n  template: `\r\n    <div style=\"display: flex;\">\r\n        <wc-button\r\n            [label]=\"label\"\r\n            (buttonClick)=\"buttonClick()\">\r\n        </wc-button>\r\n    </div>`\r\n})"
                }
            ]
        },
        "groupedFunctions": {
            "src/app/clients/api.client.ts": [
                {
                    "name": "blobToText",
                    "file": "src/app/clients/api.client.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "blob",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "Observable<string>",
                    "jsdoctags": [
                        {
                            "name": "blob",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "throwException",
                    "file": "src/app/clients/api.client.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "status",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "response",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "headers",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "result",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "returnType": "Observable<any>",
                    "jsdoctags": [
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "status",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "response",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "headers",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "result",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ]
        },
        "groupedEnumerations": {
            "src/app/clients/api.client.ts": [
                {
                    "name": "LoginError",
                    "childs": [
                        {
                            "name": "_0",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": 0
                        },
                        {
                            "name": "_1",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": 1
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/clients/api.client.ts"
                },
                {
                    "name": "RegisterError",
                    "childs": [
                        {
                            "name": "_0",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": 0
                        },
                        {
                            "name": "_1",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": 1
                        },
                        {
                            "name": "_2",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": 2
                        },
                        {
                            "name": "_3",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": 3
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/clients/api.client.ts"
                }
            ],
            "src/app/models/product.ts": [
                {
                    "name": "TypeofFood",
                    "childs": [
                        {
                            "name": "Meat",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "Drink",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "Cereal",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "Vegetable",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "Fruit",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "Confection",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "Bake",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "Garnish",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "Berrie",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/models/product.ts"
                },
                {
                    "name": "unitType",
                    "childs": [
                        {
                            "name": "Milliliters",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "Gram",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "Pieces",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/models/product.ts"
                }
            ],
            "src/app/models/meal.ts": [
                {
                    "name": "TypeOfMeal",
                    "childs": [
                        {
                            "name": "breakfast",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "lunch",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "dinner",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "snack",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/models/meal.ts"
                }
            ]
        },
        "groupedTypeAliases": {}
    },
    "routes": {
        "name": "<root>",
        "kind": "module",
        "className": "AppModule",
        "children": [
            {
                "name": "routes",
                "filename": "src/app/app-routing.module.ts",
                "module": "AppRoutingModule",
                "children": [
                    {
                        "path": "",
                        "redirectTo": "/meals",
                        "pathMatch": "full"
                    },
                    {
                        "path": "products",
                        "component": "ProductsPageComponent"
                    },
                    {
                        "path": "meals",
                        "component": "MealsPageComponent"
                    },
                    {
                        "path": "goals",
                        "component": "GoalsPageComponent"
                    },
                    {
                        "path": "settings",
                        "component": "SettingsPageComponent"
                    },
                    {
                        "path": "help",
                        "component": "HelpPageComponent"
                    },
                    {
                        "path": "login",
                        "component": "LoginPageComponent"
                    },
                    {
                        "path": "register",
                        "component": "RegisterPageComponent"
                    }
                ],
                "kind": "module"
            }
        ]
    },
    "coverage": {
        "count": 1,
        "status": "low",
        "files": [
            {
                "filePath": "src/app/app.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "AppComponent",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "class",
                "linktype": "classe",
                "name": "ApiException",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "class",
                "linktype": "classe",
                "name": "ErrorDto",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "class",
                "linktype": "classe",
                "name": "LoginDto",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "class",
                "linktype": "classe",
                "name": "LoginResultDto",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "class",
                "linktype": "classe",
                "name": "ProblemDetails",
                "coveragePercent": 0,
                "coverageCount": "0/10",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "class",
                "linktype": "classe",
                "name": "ProductDto",
                "coveragePercent": 0,
                "coverageCount": "0/10",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "class",
                "linktype": "classe",
                "name": "RegisterDto",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "class",
                "linktype": "classe",
                "name": "RegisterResultDto",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "ApiClient",
                "coveragePercent": 0,
                "coverageCount": "0/19",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IErrorDto",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ILoginDto",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "ILoginResultDto",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IProblemDetails",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IProductDto",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IRegisterDto",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "IRegisterResultDto",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "blobToText",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "throwException",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/clients/api.client.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "API_BASE_URL",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/components/wc-button/wc-button.component.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Primary",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/components/wc-button/wc-button.component.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Template",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/components/wc-button/wc-button.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "WcButtonComponent",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/models/meal.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "Meal",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/models/mealproduct.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "MealProduct",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/models/product.ts",
                "type": "class",
                "linktype": "classe",
                "name": "Product",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/models/selected-product-params.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "SelectedProductParams",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/pages/body/goals-page/goals-page.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "GoalsPageComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/pages/body/help-page/help-page.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "HelpPageComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/pages/body/login-page/login-page.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "LoginPageComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/pages/body/meals-page/amount-dialog/amount-dialog.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "AmountDialogComponent",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/pages/body/meals-page/meals-page.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "MealsPageComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/pages/body/meals-page/meals-part/meals-part.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "MealsPartComponent",
                "coveragePercent": 0,
                "coverageCount": "0/24",
                "status": "low"
            },
            {
                "filePath": "src/app/pages/body/meals-page/products-part/products-part.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ProductsPartComponent",
                "coveragePercent": 0,
                "coverageCount": "0/19",
                "status": "low"
            },
            {
                "filePath": "src/app/pages/body/products-page/products-page.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ProductsPageComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/pages/body/register-page/register-page.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "RegisterPageComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/pages/body/settings-page/settings-page.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "SettingsPageComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/pages/footer/footer.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "FooterComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/pages/header/header.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "HeaderComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/pages/menu/menu.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "MenuComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/pages/prompt/prompt.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PromptComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/services/http.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "HttpService",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/meals.controller.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "MealsController",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/services/meals.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "MealsService",
                "coveragePercent": 0,
                "coverageCount": "0/16",
                "status": "low"
            },
            {
                "filePath": "src/app/services/products.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "ProductsService",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/environments/environment.prod.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "environment",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/environments/environment.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "environment",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Button.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Large",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Button.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Primary",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Button.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Secondary",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Button.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Small",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Button.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Template",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Header.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "LoggedIn",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Header.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "LoggedOut",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Header.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Template",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Page.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "LoggedIn",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Page.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "LoggedOut",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/Page.stories.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "Template",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/User.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "User",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/stories/button.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ButtonComponent",
                "coveragePercent": 83,
                "coverageCount": "5/6",
                "status": "very-good"
            },
            {
                "filePath": "src/stories/header.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "HeaderComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/stories/page.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PageComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/test.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "context",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/test.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "require",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            }
        ]
    }
}